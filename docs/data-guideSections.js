var guideSections =[{"name":"","guides":[]},{"name":"Getting Started","guides":[{"name":"../docs/guides/overview.md","body":"# Overview\n\nCommands, Options, Values, Arguments. A simple yet robust command line argument parsing library for Zig.\n\nCova is based on the idea that arguments will fall into one of three Argument Types: Commands, Options, or Values. These Types are assembled into a single Command struct which is then used to parse argument tokens.\n\nThis guide is a Work in Progress, but is intended to cover everything from how to install the cova libary into a projectx, to basic setup and many of the library's advanced features. For a more direct look at the library in action, checkout `examples/covademo.zig`, `examples/basic-app.zig`, and the tests in `src/cova.zig` where many of the examples are lifted directly from.\n\nWhile this guide does cover several aspects of the libary, everything that's needed to get up and running can be found in the Getting Started section.\n"},{"name":"../docs/guides/getting_started/install.md","body":"# Install\n## Package Manager\n1. Find the latest `v#.#.#` commit [here](https://github.com/00JCIV00/cova/commits/main).\n2. Copy the full SHA for the commit.\n3. Add the dependency to `build.zig.zon`:\n```bash\nzig fetch --save \"https://github.com/00JCIV00/cova/archive/<GIT COMMIT SHA FROM STEP 2 HERE>.tar.gz\"\n```\n4. Add the dependency and module to `build.zig`:\n```zig\n// Cova Dependency\nconst cova_dep = b.dependency(\"cova\", .{ .target = target });\n// Cova Module\nconst cova_mod = cova_dep.module(\"cova\");\n// Executable\nconst exe = b.addExecutable(.{\n    .name = \"cova_example\",\n    .root_source_file = .{ .path = \"src/main.zig\" },\n    .target = target,\n    .optimize = optimize,\n});\n// Add the Cova Module to the Executable\nexe.addModule(\"cova\", cova_mod);\n```\n\n## Package Manager - Alternative\nNote, this method makes Cova easier to update by simply re-running `zig fetch --save https://github.com/00JCIV00/cova/archive/[BRANCH].tar.gz`. However, it can lead to non-reproducible builds because the url will always point to the newest commit of the provided branch. Details can be found in [this discussion](https://ziggit.dev/t/feature-or-bug-w-zig-fetch-save/2565).\n1. Choose a branch to stay in sync with. \n- `main` is the latest stable branch.\n- The highest `v#.#.#` is the development branch.\n2. Add the dependency to `build.zig.zon`:\n ```shell\n zig fetch --save https://github.com/00JCIV00/cova/archive/[BRANCH FROM STEP 1].tar.gz\n ```\n3. Continue from Step 4 above.\n\n\n## Build the Basic-App Demo from source\n1. Use Zig v0.12 for your system. Available [here](https://ziglang.org/download/).\n2. Run the following in whichever directory you'd like to install to:\n```\ngit clone https://github.com/00JCIV00/cova.git\ncd cova\nzig build basic-app -Doptimize=ReleaseSafe\n```\n3. Try it out!\n```\ncd bin \n./basic-app help\n```\n"},{"name":"../docs/guides/getting_started/quick_setup.md","body":"# Quick Setup\n- This is a minimum working demo of Cova integrated into a project.\n\n```zig\nconst std = @import(\"std\");\nconst cova = @import(\"cova\");\nconst CommandT = cova.Command.Base();\n\npub const ProjectStruct = struct {\n    pub const SubStruct = struct {\n        sub_uint: ?u8 = 5,\n        sub_string: []const u8,\n    },\n\n    subcmd: SubStruct = .{},\n    int: ?i4 = 10,\n    flag: ?bool = false,\n    strings: [3]const []const u8 = .{ \"Three\", \"default\", \"strings.\" },\n};\n\nconst setup_cmd = CommandT.from(ProjectStruct);\n\npub fn main() !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const alloc = arena.allocator();\n    const stdout = std.io.getStdOut().writer();\n\n    const main_cmd = try setup_cmd.init(alloc, .{});\n    defer main_cmd.deinit();\n\n    var args_iter = try cova.ArgIteratorGeneric.init(alloc);\n    defer args_iter.deinit();\n\n    cova.parseArgs(&args_iter, CommandT, &main_cmd, stdout, .{}) catch |err| switch(err) {\n        error.UsageHelpCalled,\n        else => return err,\n    }\n    try cova.utils.displayCmdInfo(CommandT, &main_cmd, alloc, stdout);\n}\n``` \n\n## Breakdown\nThis is a detailed explanation of the code above.\n- Imports\n```zig\n...\n// The main cova library module. This is added via `build.zig` & `build.zig.zon` during\n// installation.\nconst cova = @import(\"cova\");\n\n// The Command Type for all Commands in this project.\nconst CommandT = cova.Command.Base();\n...\n```\n\n- A Valid Project Struct. The rules for what makes a Valid struct and how they're converted into Commands can be found in the API Documentation under `cova.Command.Custom.from()`.\n```zig\n...\n// This comptime struct is valid to be parsed into a cova Command.\npub const ProjectStruct = struct {\n    // This nested struct is also valid.\n    pub const SubStruct = struct {\n        // Optional Primitive type fields will be converted into cova Options.\n        // By default, Options will be given a long name and a short name based on the\n        // field name. (i.e. int = `-i` or `--int`)\n        sub_uint: ?u8 = 5,\n\n        // Primitive type fields will be converted into Values.\n        sub_string: []const u8,\n    },\n\n    // Struct fields will be converted into cova Commands.\n    subcmd: SubStruct = .{},\n\n    // The default values of Primitive type fields will be applied as the default value\n    // of the converted Option or Value.\n    int: ?i4 = 10,\n\n    // Optional Booleans will become cova Options that don't take a Value and are set to\n    // `true` simply by calling the Option's short or long name.\n    flag: ?bool = false,\n\n    // Arrays will be turned into Multi-Values or Multi-Options based on the array's\n    // child type.\n    strings: [3]const []const u8 = .{ \"Three\", \"default\", \"strings.\" },\n};\n...\n```\n\n- Creating the Comptime Command.\n```zig\n...\n// `from()` method will convert the above Struct into a Command.\n// This must be done at Comptime for proper Validation before Initialization to memory\n// for Runtime use.\nconst setup_cmd = CommandT.from(ProjectStruct);\n...\n```\n\n- Command Validation and Initialization to memory for Runtime Use.\n```zig\n...\npub fn main() !void {\n    ...\n\n    // The `init()` method of a Command instance will Validate the Command's\n    // Argument Types for correctness and distinct names, then it will return a\n    // memory allocated copy of the Command for argument token parsing and\n    // follow on analysis.\n    const main_cmd = try setup_cmd.init(alloc, .{});\n    defer main_cmd.deinit();\n    \n    ...\n}\n```\n\n- Set up the Argument Iterator.\n```zig\npub fn main() {\n    ...\n\n    // The ArgIteratorGeneric is used to step through argument tokens.\n    // By default (using `init()`), it will provide Zig's native, cross-platform ArgIterator\n    // with end user argument tokens. There's also cova's RawArgIterator that can be used to\n    // parse any slice of strings as argument tokens.\n    var args_iter = try cova.ArgIteratorGeneric.init(alloc);\n    defer args_iter.deinit();\n\n    ...\n}\n```\n\n- Parse argument tokens and Display the result.\n```zig\npub fn main() !void {\n    ...\n\n    // The `parseArgs()` function will parse the provided ArgIterator's (`&args_iter`)\n    // tokens into Argument Types within the provided Command (`main_cmd`).\n    try cova.parseArgs(&args_iter, CommandT, &main_cmd, stdout, .{});\n\n    // Once parsed, the provided Command will be available for analysis by the\n    // project code. Using `utils.displayCmdInfo()` will create a neat display\n    // of the parsed Command for debugging.\n    try utils.displayCmdInfo(CommandT, &main_cmd, alloc, stdout);\n}\n```\n"},{"name":"../docs/guides/getting_started/naming_conventions.md","body":"# Naming Conventions\nCova follows Zig's naming conventions for the most part. This guide covers the few places where it deviates and certain conventions that may be peculiar in the Library and/or Guide.\n\n## Argument Type vs Argument\nThe terms 'Argument Type' and 'Argument' are used throughout this guide. While the terms are related, they're not inter-changeable. \n\n'Argument Type' refers to the Types `cova.Command.Custom`, `cova.Option.Custom`, and `cova.Value.Custom`. These are the base Types of Cova which can be configured to apply customizations to all of their respective instances. For brevity, these are also referred to as `CommandT`, `OptionT`, and `ValueT`. \n\nConversely, `Argument` refers to any instance of those Types, which can also be referenced individualy as a Command, Option, or Value.\n\n## Callback Functions\nCova uses Callback Functions to allow the library user to overwrite or otherwise customize certain aspects of the argument parsing process. The functions are represented as fields within both the Argument Type Config Structs and Instances. They're always some variation of the Type `?*const fn()` (with varying parameters and Return Types) and end with the `_fn` suffix to distinguish them from both other fields and normal functions.\n\n## Functions vs Methods\nWhile Zig doesn't officially have methods, it does have 'Member Functions'. These are functions that belong to a Type and whose first parameter is an instance or pointer of that Type. They work effectively the same way as methods in other languages, so the term 'method' is used in this guide for both brevity and clarity.\n\n## Global & Child Type Prefixes\nSome fields are shared between both the Argument Type Config Structs and their Instances. These fields all share the purpose of overwriting some default property with varying levels of precedence as denoted by their prefixes:\n1. No Prefix: These will always be found directly on the Argument they apply to and have the highest precedence. They apply only to that Argument.\n2. `child_type_`: These are only found within Value Config Structs and have the 2nd highest precedence. They apply to any Values with the corresponding Child Type.\n3. `global_`: These will always be found within a Config Struct and have lowest precedence. They apply to all Arguments of the configured Type.\n\n## Title Case\nTypes and certain Key Concepts will be shown in Title Case for distinction. For Types, this includes their descriptions, such as 'Command Type', and their Type Names like in 'CommandT'.\n\n## Users\nThis guide makes reference to both 'Library' and 'End' users. 'Library user' refers to the developer using the Cova library (probably you, the reader) and 'End user' refers to the user of an application or project built with the help of the Cova library.\n\n"}]},{"name":"Argument Types","guides":[{"name":"../docs/guides/arg_types/command.md","body":"# Command\nA Command is a container Argument Type for sub-Commands, Options, and Values. It can contain any mix of those Argument Types or none at all if it's to be used as a standalone Command (i.e. `covademo help`). \n\n## Configuring a Command Type\nBefore a Command is used within a project, a Command Type should be configured. A Command Type is used to set common-to-all properties of each Command created from it. Typically, this will cover the main Command of a project and all of its sub-Commands. The easiest way to configure a Command Type is to simply use `cova.Command.Base`() which is the default Command Type. To configure a custom Command Type, use `cova.Command.Custom`() with a `cova.Command.Config` (`config`) which provides several customizations to set up the Option Type, Value Type, Help/Usage messages, Mandatory sub-Commands/Values, and max sub Arguments. Once configured, the Command Type has access to all of the functions under `cova.Command.Custom` and any Command created from the Command Type similarly has access to all of the corresponding methods.\n\n## Setting up a Command\nCommands are meant to be set up in Comptime and used in Runtime. This means that the Command and all of its subordinate Arguments (Commands, Options, and Values) should be Comptime-known, allowing for proper Validation which provides direct feedback to the library user during compilation instead of preventable errors to the end user during Runtime. \n\nThere are two ways to set up a Command. The first is to use Zig's standard syntax for creating a struct instance and fill in the fields of the previously configured Command Type. Alternatively, if the project has a Struct, Union, or Function Type that can be represented as a Command, the `cova.Command.Custom.from`() function can be used to create the Command.\n\nAfter they're set up, Commands should be Validated and Allocated to the heap for Runtime use. This is accomplished using `cova.Command.Custom.init`(). At this point, the data within the Command should be treated as read-only by the libary user, so the library is set up to handle initialized Commands as constants (`const`).\n\n## Additional Info\nFor easy analysis, parsed Commands can be converted to valid Structs or Unions using the `cova.Command.Custom.to`() function, or called as Functions using the `cova.Command.Custom.callAs`() function. Other functions for analysis include `cova.Command.Custom.checkCmd`() and `cova.Command.Custom.matchCmd`() to access specific sub-Commands, creating a String HashMap<Name, Value/Option> for Options or Values using the respective `cova.Command.Custom.getOpts`() or `cova.Command.Custom.getVals`() methods, and using the `cova.Command.Custom.checkFlag`() method to simply check if a sub-Argument was set. Usage and Help statements for a Command can also be generated using the `cova.Command.Custom.usage`() and `cova.Command.Custom.help`() methods respectively.\n\n## Example:\n```zig\n...\npub const cova = @import(\"cova\");\npub const CommandT = cova.Command.Custom(.{ global_help_prefix = \"CovaDemo\" });\n\n// Comptime Setup\nconst setup_cmd: CommandT = .{\n    .name = \"covademo\",\n    .description = \"A demo of the Cova command line argument parser.\",\n    .sub_cmds = &.{\n        .{\n            .name = \"sub_cmd\",\n            .description = \"This is a Sub Command within the 'covademo' main Command.\",\n        },\n        command_from_elsewhere,\n        CommandT.from(SomeValidStructType),\n    }\n    .opts = { ... },\n    .vals = { ... },\n};\n\npub fn main() !void {\n    ...\n    // Runtime Use\n    const main_cmd = try setup_cmd.init(alloc);\n    defer main_cmd.deinit();\n\n    cova.parseArgs(..., &main_cmd, ...);\n    utils.displayCmdInfo(CustomCommand, &main_cmd, alloc, stdout);\n}\n```\n"},{"name":"../docs/guides/arg_types/option.md","body":"# Option\nAn Option (also known as a Flag) is an Argument Type which wraps a Value and is typically optional. They should be used for Values that an end user is not always expected to provide. Additionally, unlike Values, they can be expected in any order since they are set by name.\n\n## Configuring an Option Type\nSimilar to Commands, an Option Type should be configured before any Options are created. Fortunately, the process is virtually the same as with Command Types and both configurations are designed to be done simultaneously. The standard way to configure an Option Type is by configuring the `cova.Command.Config.opt_config` field during Command Type configuration. This field is a `cova.Option.Config` and works effectively the same way as its Command counterpart. If the field is not configured it will be set to the default configuration. Done this way, the Option Type will be a part of the Command Type and will have access to all of the respective functions and methods within `cova.Option.Custom`().\n\n## Setting up an Option\nThe most straightforward way to set up an Option is to simply use Zig's standard syntax for filling out a struct. More specifically, Options can bet set up within the `cova.Command.Custom.opts` field of a Command using Anonymous Struct (or Tuple) syntax. Similarly, an Option's internal Value can also be set up this way via the Option's `val` field.\n\nAlternatively, Options will be created automatically when using `cova.Command.Custom.from`().\n\n## Additional Info\nAn Option must have a Short Name (ex: `-h`), a Long Name (ex: `--name \"Lilly\"`), or both. The prefixes for both Short and Long names are set by the library user during a normal setup. If the wrapped Value of an Option has a Boolean Type it will default to `false` and can be set to `true` using the Option without a following argument token from the end user (ex: `-t` or `--toggle`). They also provide `usage()` and `help()` methods similar to Commands.\n\n## Example:\n```zig\n// Within a Command\n...\n.opts = &.{\n    .{\n        .name = \"string_opt\",\n        .description = \"A string option.\",\n        .short_name = 's',\n        .long_name = \"string\",\n        .val = ValueT.ofType([]const u8, .{\n            .name = \"stringVal\",\n            .description = \"A string value.\",\n        }),\n    },\n    .{\n        .name = \"int_opt\",\n        .description = \"An integer option.\",\n        .short_name = 'i',\n        .long_name = \"int\",\n        .val = ValueT.ofType(i16, .{\n            .name = \"int_opt_val\",\n            .description = \"An integer option value.\",\n            .val_fn = struct{ fn valFn(int: i16) bool { return int < 666; } }.valFn\n        }),\n    },\n},\n```\n"},{"name":"../docs/guides/arg_types/value.md","body":"# Value\nA Value (also known as a Positional Argument) is an Argument Type that is expected in a specific order and should be interpreted as a specific Type. The full list of available Types can be seen in `cova.Value.Generic` and customized via `cova.Value.Custom`, but the basics are Boolean, String (`[]const u8`), Integer (`u/i##`), or Float (`f##`). A single Value can store individual or multiple instances of one of these Types. Values are also used to hold and represent the data held by an Option via the `cova.Option.Custom.val` field. As such, anything that applies to Values is also \"inherited\" by Options.\n\n## Understanding Typed vs Generic vs Custom Values\nThe base data for a Value is held within a `cova.Value.Typed` instance. However, to provide flexibility for the cova library and library users, the `cova.Value.Generic` union will wrap any `cova.Value.Typed` and provide access to several common-to-all methods. This allows Values to be handled in a generic manner in cases such as function parameters, function returns, collections, etc. However, if the actual parsed data of the Value is needed, the appropriate `cova.Value.Generic` field must be used. Field names for this union are simply the Value's Child Type name with the exception of `[]const u8` which is the `.string` field.\n\nFinally, the `cova.Value.Custom` sets up and wraps `cova.Value.Generic` union. This Type is used similary to `cova.Command.Custom` and `cova.Option.Custom`. It allows common-to-all properties of Values within a project to be configured and provides easy methods for accessing properties of individual Values. \n\n## Configuring a Value Type\nThis process mirrors that of Option Types nearly one-for-one. A `cova.Value.Config` can be configured directly within the Command Config via the `cova.Command.Config.val_config` field. If not configured, the defaults will be used. A major feature of the Custom Value Type and Generic Value Union combination is the ability to set custom types for the Generic Value Union. This is accomplished via the `cova.Value.Config`, by setting the `cova.Value.Config.custom_types` field.\n\n### Adding Custom Child Types\nAdding custom Child Types allows Cova to parse argument tokens into virtually any Type. This is accomplished by first adding the custom Child Types to the `Value.Config.custom_types` field, then (non-primitive Types) specifying parsing functions for these Types via `Value.Config.child_type_parse_fns` as seen here:\n```zig\nconst CommandT = cova.Command.Custom(cova.Command.Config{\n    .global_help_prefix = \"Example\",\n    .val_config = .{\n        .custom_types = &.{ \n            std.net.Address,\n            std.fs.File,\n        },\n        .child_type_parse_fns = &.{ \n            .{\n                .ChildT = std.net.Address,\n                .parse_fn = struct{\n                    pub fn parseIP(addr: []const u8, _: std.mem.Allocator) !std.net.Address {\n                        var iter = std.mem.splitScalar(u8, addr, ':');\n                        return net.Address.parseIp(\n                            iter.first(), \n                            try std.fmt.parseInt(u16, iter.next() orelse \"-\", 10), \n                        ) catch |err| {\n                            std.log.err(\"The provided IP address '{s}' is invalid.\", .{ addr }); \n                            return err;\n                        };\n                    }\n                }.parseIP,\n            },\n            .{\n                .ChildT = std.fs.File,\n                .parse_fn = struct{\n                    pub fn parseFile(path: []const u8, _: std.mem.Allocator) !std.fs.File {\n                        var cwd = std.fs.cwd();\n                        return cwd.openFile(path, .{ .lock = .shared }) catch |err| {\n                            std.log.err(\"The provided path to the File '{s}' is invalid.\", .{ path }); \n                            return err;\n                        };\n                    }\n                }.parseFile,\n            },\n        },\n    }   \n});\n```\n\n## Setting up a Value\nSimilar to Options, Values are designed to be set up within a Command. Specifically, within a Command's `cova.Command.Custom.vals` field. This can be done using a combination of Zig's Union and Anonymous Struct (Tuple) syntax or by using the `cova.Value.ofType`() function.\n\nValues can be given a Default value using the `cova.Value.Typed.default_val` field as well as an alternate Parsing Function and a Validation Function using the `cova.Value.Typed.parse_fn` and `cova.Value.Typed.valid_fn` fields respectively. An example of how to create an anonymous function for these fields can be seen below. There are also common functions and function builders available within both `cova.Value.ParsingFns` and `cova.Value.ValidationFns`. \n\nThese functions allow for simple and powerful additions to how Values are parsed. For instance, the `true` value for Booleans can be expanded to include more words (i.e. `true = \"yes\", \"y\", \"on\"`), a numeric value can be limited to a certain range of numbers (i.e. `arg > 10 and arg <= 1000`), or an arbitrary string can be converted to something else (i.e. `\"eight\" = 8`). Moreover, since these functions all follow normal Zig syntax, they can be combined into higher level functions for more complex parsing and validation. Finally, the custom parsing functions in particular allow Custom Types to be parsed directly from a given argument token. For example, converting a given filepath into a `std.fs.File`.\n\nExample:\n```zig\n// Within a Command\n...\n.vals = &.{\n    Value.ofType([]const u8, .{\n        .name = \"str_val\",\n        .description = \"A string value for the command.\",\n    }),\n    // Using Zig's union creation syntax\n    .{ .generic = .{ .u128, .{\n        .name = \"cmd_u128\",\n        .description = \"A u128 value for the command.\",\n        // Default Value\n        .default_val = 654321,\n        // Validation Function\n        .valid_fn = struct{ fn valFn(val: u128) bool { return val > 123 and val < 987654321; } }.valFn,\n    } } },\n}\n```\n\n## Additional Info \nValues will be parsed to their corresponding types which can then be retrieved using `get()` for Inidivual Values or `getAll()` for Multi-Values. \n"}]},{"name":"Parsing & Analysis","guides":[{"name":"../docs/guides/parsing_analysis/parsing.md","body":"# Parsing\nParsing is handled by the `cova.parseArgs`() function. It takes in a pointer to an ArgIterator (`args`), a Command type (`CommandT`), a pointer to an initialized Command (`cmd`), a Writer (`writer`), and a ParseConfig (`parse_config`), then parses each argument token sequentially. The results of a successful parse are stored in the provided Command (`cmd`) which can then be analyzed by the library user's project code.\n\nNotably, the `cova.parseArgs`() function can return several errorrs, most of which (especially `error.UsageHelpCalled`) can be safely ignored when using the default behavior. This is demonstrated below.\n\n## Default Setup\nFor the default setup, all that's needed is a pointer to an initialized `cova.ArgIteratorGeneric` (`&args_iter`), the project's Command Type (`CommandT`), a pointer to an initialized Command (`&main_cmd`), a Writer to stdout (`stdout`), and the default `ParseConfig` (`.{}`) as shown here:\n\n```zig\nconst cova = @import(\"cova\");\n\n// Command Type\nconst CommandT = cova.Command.Custom(.{});\n\n// Comptime Setup Command\nconst setup_cmd: CommandT = .{ ... };\n\npub fn main() !void {\n    // Allocator\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const alloc = arena.allocator();\n\n    // Command\n    // Note, the Command Type and `setup_cmd` are created during comptime before the `main()` function.\n    const main_cmd = try setup_cmd.init(alloc, .{}); \n    defer main_cmd.deinit();\n\n    // Argument Iterator\n    var args_iter = try cova.ArgIteratorGeneric.init(alloc);\n    defer args_iter.deinit();\n\n    // Writer to stdout\n    const stdout = std.io.getStdOut().writer();\n\n    // Parse Function\n    cova.parseArgs(&args_iter, CommandT, &main_cmd, stdout, .{}) catch |err| switch (err) {\n        error.UsageHelpCalled,\n        else => return err,\n    };\n}\n```\n\n## Custom Setup\n### Choosing an ArgIterator\nThere are two implementations to choose from within `cova.ArgIteratorGeneric`: `.zig` and `.raw`.\n- `.zig`: This implementation uses a `std.process.ArgIterator`, which is the default, cross-platform ArgIterator for Zig. It should be the most common choice for normal argument token parsing since it pulls the argument string from the process and tokenizes it into iterable arguments. Setup is handled by the `.init()` method as shown above.\n- `.raw`: This implementation uses the `cova.RawArgIterator` and is intended for testing, but can also be useful parsing externally sourced argument tokens. \"Externally sourced\" meaning argument tokens that aren't provided by the process from the OS or Shell when the project application is run. It's set up as follows:\n```zig\nconst test_args: []const [:0]const u8 = &.{ \"test-cmd\", \"--string\", \"opt string 1\", \"-s\", \"opt string 2\", \"--int=1,22,333,444,555,666\", \"--flo\", \"f10.1,20.2,30.3\", \"-t\", \"val string\", \"sub-test-cmd\", \"--sub-s=sub_opt_str\", \"--sub-int\", \"21523\", \"help\" }; \nvar raw_iter = RawArgIterator{ .args = test_args };\nvar test_iter = ArgIteratorGeneric.from(raw_iter);\ntry parseArgs(&test_iter...);\n```\n\n#### Tokenization\nAs mentioned, the `std.process.ArgIterator` tokenizes its arguments automatically. However, if the `cova.RawArgIterator` is needed, then the `cova.tokenizeArgs`() function can be used to convert an argument string (`[]const u8`) into a slice of argument token strings (`[]const []const u8`). This slice can then be provided to `cova.RawArgIterator`. The `cova.TokenizeConfig` can be used to configure how the argument string is tokenized. Example:\n```zig\nvar arena = std.heap.ArenaAllocator.init(testing.allocator);\ndefer arena.deinit();\nconst alloc = arena.allocator();\nconst arg_str = \"cova struct-cmd --multi-str \\\"demo str\\\" -m 'a \\\"quoted string\\\"' -m \\\"A string using an 'apostrophe'\\\" 50\";\nconst test_args = try tokenizeArgs(arg_str, alloc, .{});\n```\n\n### Creating a Command Type and a Command\nAs described above, the parsing process relies on the creation of a Command Type and a main Command. The specifics for this can be found under `cova.Command` in the API and the [Command Guide](../arg_types/command) in the Guides.\n\nThe basic steps are:\n1. Configure a Command Type.\n2. Create a comptime-known Command.\n3. Initialize the comptime-known Command for runtime-use.\n\n### Setting up a Writer\nThe Writer is used to output Usage/Help messages to the end user in the event of an error during parsing. The standard is to use a Writer to `stdout` or `stderr` for this as shown above. However, a Writer to a different file can also be used to avoid outputting to the end user as shown here:\n```zig\nvar arena = std.heap.ArenaAllocator.init(testing.allocator);\ndefer arena.deinit();\nconst alloc = arena.allocator();\n\nvar writer_list = std.ArrayList(u8).init(alloc);\ndefer writer_list.deinit();\nconst writer = writer_list.writer();\n```\n\n### Parsing Configuration\nThe `cova.ParseConfig` allows for several configurations pertaining to how argument tokens are parsed.\n\n### Custom Parsing & Validation Functions\n#### Parsing Functions\nValues and, by extension, Options can be given custom functions for parsing from an argument token to the Value's Child Type. These functions will take precedence over the default parsing and can be given at two levels, directly to the Value and to all Value's with a specific Child Type. Regardless of which level these functions are provided at, they must follow the same general structure. The first parameters must be a `[]const u8` for the argument token and the second must be a `std.mem.Allocator` that will be provided by Cova based on the Allocator given during Command Initialization (though this can be skipped using `_: std.mem.Allocator`). Finally, the Return Type must be an Error Union with the Value's Child Type.\n\n1. `Value.Typed.parse_fn` is the field used to provide a parsing function directly to a Value as it's being set up. This function has the highest priority and is used as follows:\n```zig\n//Within a Command\n.vals = &.{\n    ValueT.ofType(bool, .{\n        .name = \"pos_or_neg\",\n        .description = \"An example boolean that must be set as 'positive' or 'negative'.\",\n        .parse_fn = struct{\n            pub fn parseBool(arg: []const u8, _: std.mem.Allocator) !bool {\n                if (std.ascii.eqlIgnoreCase(arg, \"positive\") return true;\n                if (std.ascii.eqlIgnoreCase(arg, \"negative\") return false;\n                else return error.BoolParseError;\n            }\n        }.parseBool,\n    }),\n},\n```\n2. `Value.Config.child_type_parse_fn` is the field used to provide a parsing function to all Value's that have a specific Child Type. These functions rank second in priority, behind `Value.Typed.parse_fn` but ahead of the default parsing. An example can be seen [here](../arg_types/value.md#adding-custom-child-types).\n\n#### Validation Functions\nValidation Functions are set up very similarly to Parsing Functions. They differ in that they're used to validate a Value after it's been parsed to its Child Type. As such, their structure differs by requiring the first parameter to be an instance of the Value's Child Type and the Return Type to be an Error Union with a Boolean. Notably, these functions can only be applied directly to a Value.\n\nExample:\n```zig\n// Within a Command\n.opts = &.{\n    .{\n        .name = \"verbosity_opt\",\n        .description = \"Set the CovaDemo verbosity level. (WIP)\",\n        .short_name = 'v',\n        .long_name = \"verbosity\",\n        .val = ValueT.ofType(u4, .{\n            .name = \"verbosity_level\",\n            .description = \"The verbosity level from 0 (err) to 3 (debug).\",\n            .default_val = 3,\n            .valid_fn = struct{ fn valFn(val: u4, _: mem.Allocator) bool { return val >= 1 and val <= 3; } }.valFn,\n        }),\n    },\n},\n```\n"},{"name":"../docs/guides/parsing_analysis/analysis.md","body":"# Analysis\nOnce initialized and parsed, a Command can be analyzed. In the context of Cova, Analysis refers to dealing with the result of parsed Argument Types. This can range from simply debugging the results, to checking if an Argument Type was set, to utilizing the resulting values in a project. The Command Type has several functions and methods to make this easier, with methods for checking and matching sub-Commands being the standard starting point. Addtionally, it's possible to convert the Command into a comptime-known Struct, Union, or Function Type and use the resulting Type normally. For a more direct look, all of the sub-Arguments of a Command can also be analyzed individually.\n\n## Checking and Matching Sub Commands\nThe `cova.Command.Custom.checkSubCmd`() and `cova.Command.Custom.matchSubCmd`() methods are designed to be the starting point for analysis. The check function simply returns a Boolean value based on a check of whether or not the provided Command name (`cmd_name`) is the same as the Command's active sub-Command. The match function works similarly, but will return the active sub-Command if it's matched or `null` otherwise. Chaining these methods into conditional `if/else` statements makes iterating over and analyzing all sub-Commands of each Command simple and easy, even when done recursively.\n\nFor a detailed example of these methods in action, refer to the [Basic-App](https://github.com/00JCIV00/cova/blob/main/examples/basic_app.zig) demo under the `// - Handle Parsed Commands` comment in the `main()` function.\n\nOf note, there is also the `cova.Command.Custom.SubCommandsEnum`() method which will create an Enum of all of the sub-Commands of a given Command. Unfortunately, the Command this is called from must be comptime-known, making it cumbersome to use in all but the most basic of cases. For the time being, the check and match methods above should be preferred.\n\n## Conversions\n### To a Struct or Union\nOnce a Command has been initialized and parsed to, using the `cova.Command.Custom.to`() method will convert it into a struct or union of a comptime-known Struct or Union Type. The function takes a valid comptime-known Struct or Union Type (`ToT`) and a ToConfig (`to_config`). Details for the method, including the rules for a valid Struct or Union Type, can be found under `cova.Command.Custom.to`(). Once sucessfully created, the new struct or union can be used normally throughout the rest of the project. This process looks as follows:\n```zig\nconst DemoStruct {\n    // Valid field values\n    ...\n};\n\n...\n\npub fn main() !void {\n    ...\n    const main_cmd = ...;\n    // Parse into the initialized Command\n    ...\n\n    // Convert to struct\n    const demo_struct = main_cmd.to(DemoStruct, .{}); \n\n    // Use the struct normally\n    some_fn(demo_struct);\n}\n\n```\n\nThe `cova.Command.Custom.ToConfig` can be used to specify how the Command will be converted to a struct.\n\n### To a Function\nAlternatively, the Command can also be called as a comptime-known function using `cova.Command.Custom.callAs`(). This method takes a function (`call_fn`), an optional self parameter for the function (`fn_self`), and the return Type of the function (`ReturnT`) to call the function using the Command's Arguments as the parameters. Example:\n```zig\npub fn projectFn(some: anytype, params: []const u8) void {\n    _ = some;\n    _ = params;\n}\n\n...\n\npub fn main() !void {\n    ...\n    const main_cmd = ...;\n    // Parse into the initialized Command\n    ...\n\n    // Call as a Function\n    main_cmd.callAs(projectFn, null, void); \n}\n\n```\n\n## Checking and Matching Options\nThere are a few ways to analyze Options as well, which include the `cova.Command.Custom.checkOpts`() and `cova.Command.Custom.matchOpts`() methods. These work similarly to their sub-Command counterparts detailed above. Additionally, the `cova.Command.Custom.OptionsCheckConfig` can be passed to these methods to change the kind of boolean logic they use.\n\n## Direct Access\nTo directly access the sub-Argument of a Command the following fields and methods of `cova.Command.Custom` can be used: \n### Fields\n- `sub_cmd`: Access the sub Command of this Command if set.\n- `opts`: Access the Options of this Command if any.\n- `vals`: Access the Values of this Command if any.\n\n### Methods\n- `checkFlag()`: Check if a Command or Boolean Option/Value is set for this Command.\n- `getOpts()` / `getOptsAlloc`: Get a String Hashmap of all of the Options in this Command as `<Name, Option>`.\n- `getVals()` / `getValsAlloc`: Get a String Hashmap of all of the Values in this Command as `<Name, Value>`.\n\n### Examples\nCheck the `cova.utils.displayCmdInfo`() and `cova.utils.displayValInfo`() functions for examples of direct access.\n"},{"name":"../docs/guides/parsing_analysis/usage_help.md","body":"# Usage & Help Message\nBy default, Usage and Help messages are created based on the metadata of Arguments, and are displayed when there's an error during Parsing. Setting up the display for Usage and Help messages is as simple as setting up each Argument as seen in their respective guides. That said, the way they are created and the criteria for when they're displayed can be fully customized by the libary user. \n\n## Parsing Error Messages\nThe `cova.ParseConfig.err_reaction` field is used to help control what the end user sees if there's an error during parsing. In particular, it allows for a Usage message, a Help message, or no message at all to be displayed following an error.  \n\n## Argument Usage & Help Functions\nEach Argument Type has `usage()` and `help()` functions that can be called on an Argument to create messages. The most commonly used of these functions are `cova.Command.Custom.usage`() and `cova.Command.Custom.help`() which create and write out a Usage or Help message based on the Command's sub Arguments.\n\n## Custom Usage & Help Formats\nThe Config for each Argument Type provides Format fields with the `_fmt` suffix that can be used to customize how Usage and Help messages are displayed. These Format fields are each documented with their required format placeholders (details for those can be found in `std.fmt.format`). \n\nExample:\n```zig\npub const CommandT = cova.Command.Custom(.{\n    .global_help_prefix=\"Cova Usage & Help Example\",\n    .help_header_fmt = \n        \\\\ {s}COMMAND: {s}\n        \\\\ \n        \\\\ {s}DESCRIPTION: {s}\n        \\\\\n        \\\\\n    ,\n    .opt_config = .{\n        usage_fmt = \"{c}{?c}, {s}{?s} <{s} ({s})>\",\n    },\n});\n```\n\n## Custom Usage & Help Callback Functions\nFor greater flexibiliy, custom Usage & Help callback functions can be provided for each Argument Type. These functions can be given directly to an Argument, to each Value or Option with a specific Child Type, or globally to all Arguments of an Argument Type; in that order of precendence.\n\nExample:\n```zig\npub const CommandT = cova.Command.Custom(.{\n    .global_help_prefix=\"Cova Usage & Help Example\",\n    // Command Global Help Function\n    .global_help_fn = struct{\n        fn help(self: anytype, writer: anytype, _: mem.Allocator) !void {\n            const CmdT = @TypeOf(self.*);\n            const OptT = CmdT.OptionT;\n            const indent_fmt = CmdT.indent_fmt;\n    \n            try writer.print(\"{s}\\n\", .{ self.help_prefix });\n            try self.usage(writer);\n            try writer.print(\"\\n\", .{});\n            try writer.print(CmdT.help_header_fmt, .{\n                indent_fmt, self.name,\n                indent_fmt, self.description\n            });\n\n            if (self.sub_cmds) |cmds| {\n                try writer.print(\"SUBCOMMANDS\\n\", .{});\n                for (cmds) |cmd| {\n                    try writer.print(\"{s}{s}: {s}\\n\", .{\n                        indent_fmt,\n                        cmd.name,\n                        cmd.description,\n                    });\n                }\n                try writer.print(\"\\n\", .{});\n            }\n            if (self.opts) |opts| {\n                try writer.print(\"OPTIONS\\n\", .{});\n                for (opts) |opt| {\n                    try writer.print(\n                        \\\\{s}{s}{s} \"{s} ({s})\"\n                        \\\\{s}{s}{s}\n                        \\\\\n                        \\\\\n                        , .{\n                            indent_fmt,\n                            OptT.long_prefix orelse OptT.short_prefix, opt.long_name orelse \"\",\n                            opt.val.name(), opt.val.childType(),\n                            indent_fmt, indent_fmt,\n                            opt.description,\n                        }\n                    );\n                }\n            }\n            if (self.vals) |vals| {\n                try writer.print(\"VALUES\\n\", .{});\n                for (vals) |val| {\n                    try writer.print(\"{s}\", .{ indent_fmt });\n                    try val.usage(writer);\n                    try writer.print(\"\\n\", .{});\n                }\n                try writer.print(\"\\n\", .{});\n            }\n        }\n    }.help,\n    .opt_config = .{\n        // Option Global Help Function\n       .global_help_fn = struct{\n            fn help(self: anytype, writer: anytype, _: mem.Allocator) !void {\n                const indent_fmt = @TypeOf(self.*).indent_fmt;\n                try self.usage(writer);\n                try writer.print(\"\\n{?s}{?s}{?s}{s}\", .{ indent_fmt, indent_fmt, indent_fmt, self.description }); \n            }\n        }.help\n    },\n```\n\n"},{"name":"../docs/guides/parsing_analysis/arg_groups.md","body":"# Argument Groups\nArgument Groups can be used to organize Arguments based on similarities between them. For instance Commands might be organized into different categories for what they do while Options and Values can be grouped based on the kind of data they provide. These groups will be validated during the initialization to ensure that each group assigned to an Argument exists within the respective Group List for that Argument's parent Command.\n\nExample:\n```zig\npub const setup_cmd: CommandT = .{\n    .name = \"covademo\",\n    .description = \"A demo of the Cova command line argument parser.\",\n    .cmd_groups = &.{ \"RAW\", \"STRUCT-BASED\", \"FN-BASED\" },\n    .opt_groups = &.{ \"INT\", \"BOOL\", \"STRING\" },\n    .val_groups = &.{ \"INT\", \"BOOL\", \"STRING\" },\n    .sub_cmds_mandatory = false,\n    .mandatory_opt_groups = &.{ \"BOOL\" },\n    .sub_cmds = &.{\n        .{\n            .name = \"sub-cmd\",\n            .description = \"A demo sub command.\",\n            .cmd_group = \"RAW\",\n        },\n        .{\n            .name = \"basic\",\n            .description = \"The most basic Command.\",\n            .cmd_group = \"RAW\",\n        },\n        CommandT.from(DemoStruct, .{\n            .cmd_name = \"struct-cmd\",\n            .cmd_description = \"A demo sub command made from a struct.\",\n            .cmd_group = \"STRUCT-BASED\",\n        }),\n        CommandT.from(DemoUnion, .{\n            .cmd_name = \"union-cmd\",\n            .cmd_description = \"A demo sub command made from a union.\",\n            .cmd_group = \"STRUCT-BASED\",\n        }),\n        CommandT.from(@TypeOf(demoFn), .{\n            .cmd_name = \"fn-cmd\",\n            .cmd_description = \"A demo sub command made from a function.\",\n            .cmd_group = \"FN-BASED\",\n        }),\n        CommandT.from(ex_structs.add_user, .{\n            .cmd_name = \"add-user\",\n            .cmd_description = \"A demo sub command for adding a user.\",\n            .cmd_group = \"STRUCT-BASED\",\n        }),\n    },\n    .opts = &.{\n        .{\n            .name = \"string_opt\",\n            .description = \"A string option. (Can be given up to 4 times.)\",\n            .opt_group = \"STRING\",\n            .short_name = 's',\n            .long_name = \"string\",\n            .val = ValueT.ofType([]const u8, .{}),\n        },\n        .{\n            .name = \"int_opt\",\n            .description = \"An integer option. (Can be given up to 10 times.)\",\n            .opt_group = \"INT\",\n            .short_name = 'i',\n            .long_name = \"int\",\n            .val = ValueT.ofType(i16, .{}),\n        },\n    },\n    .vals = &.{\n        ValueT.ofType([]const u8, .{\n            .name = \"cmd_str\",\n            .description = \"A string value for the command.\",\n            .val_group = \"STRING\",\n        }),\n        ValueT.ofType(bool, .{\n            .name = \"cmd_bool\",\n            .description = \"A boolean value for the command.\",\n            .val_group = \"BOOL\",\n        }),\n    }\n};\n```\n\n## Usage & Help Messages\nIf these groups are used, they will be shown in Usage and Help Messages. Their are two Format fields, `cova.Command.Config.group_title_fmt` and `cova.Command.Config.group_sep_fmt`, that can be used to customize how the groups are displayed.\n\n## Parsing\nArgument Groups can be used to mandate certain groups of Options are used by setting the `cova.Command.Custom.mandatory_opt_groups` field.\n\nExample:\n```zig\npub const setup_cmd: CommandT = .{\n    .name = \"covademo\",\n    .description = \"A demo of the Cova command line argument parser.\",\n    .opt_groups = &.{ \"INT\", \"BOOL\", \"STRING\" },\n    .mandatory_opt_groups = &.{ \"BOOL\" },\n    .opts = &.{\n        .{\n            .name = \"cardinal_opt\",\n            .description = \"A cardinal number option.\",\n            .opt_group = \"INT\",\n            .short_name = 'c',\n            .long_name = \"cardinal\",\n            .val = ValueT.ofType(u8, .{}),\n        },\n        .{\n            .name = \"toggle_opt\",\n            .description = \"A toggle/boolean option.\",\n            .opt_group = \"BOOL\",\n            .short_name = 't',\n            .long_name = \"toggle\",\n        },\n        .{\n            .name = \"bool_opt\",\n            .description = \"A toggle/boolean option.\",\n            .opt_group = \"BOOL\",\n            .short_name = 'b',\n            .long_name = \"bool\",\n        },\n    },\n};\n```\n\n## Analysis\nThey can also be used to Get, Check, or Match the Values and Options of a Command. For Options, an Option Group can be passed to `cova.Command.Custom.getOpts`(), `cova.Command.Custom.checkOpt`(), or `cova.Command.Custom.matchOpt`(). For Values, a Value Group can be passed to `cova.Command.Custom.getVals`().\n"},{"name":"../docs/guides/parsing_analysis/aliases.md","body":"# Aliases\nCova allows aliasing in two areas: Commands & Options and Value Child Types.\n\n## Command & Option Aliases\nCommand aliases are created with the `cova.Command.Custom.alias_names` field and can be used to allow more than one name to be recognized as the same Command. Similarly, Option aliases are created with the `cova.Option.Custom.alias_long_names` field and can be used to allow more than one long name to be recognized as the same Option. These aliases are validated during initialization to ensure they don't conflict with other Commands/Options or their respective aliases. \n\nExample:\n```zig\npub const setup_cmd: CommandT = .{\n    .name = \"covademo\",\n    .description = \"A demo of the Cova command line argument parser.\",\n    .sub_cmds = &.{\n        .{\n            .name = \"sub-cmd\",\n            .description = \"A demo sub command.\",\n            .alias_names = &.{ \"alias-cmd\", \"test-alias\" },\n        }\n    },\n    .opts = &.{\n        .{\n            .name = \"toggle_opt\",\n            .description = \"A toggle/boolean option.\",\n            .short_name = 't',\n            .long_name = \"toggle\",\n            .alias_long_names = &.{ \"switch\", \"bool\" },\n        },\n    }\n};\n```\n\n## Value Child Type Aliases\nAliases can also be created for the Child Types of Values, allowing Usage and Help messages to be changed without changing the actual underlying Type. This can be done with either `cova.Value.Typed.alias_child_type` for a single Value or `cova.Value.Config.child_type_aliases` for all Values with a specific Child Type. For instance, Values with a `[]const u8` can be changed to show `text` instead using the following set up:\n```zig\npub const CommandT = cova.Command.Custom(.{\n    .val_config = .{\n        .child_type_aliases = &.{\n            .{\n                .ChildT = []const u8,\n                .alias = \"text\",\n            },\n        },\n    },\n});\n```\n\nOr a single Value with a Child Type of `i8` can be changed to show `number` like so:\n```zig\n.val = ValueT.ofType(i8, .{\n    .name = \"num_val\",\n    .description = \"A number value.\",\n    .default_val = 42,\n    .alias_child_type = \"number\",\n}),\n```\n"}]}];