<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Value.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">//! Argument that is expected in a specific order and should be interpreted as a specific type.</span></span>
<span class="line" id="L2"><span class="tok-comment">//!</span></span>
<span class="line" id="L3"><span class="tok-comment">//! End User Example:</span></span>
<span class="line" id="L4"><span class="tok-comment">//!</span></span>
<span class="line" id="L5"><span class="tok-comment">//! ```</span></span>
<span class="line" id="L6"><span class="tok-comment">//! # Values belonging to a Command.</span></span>
<span class="line" id="L7"><span class="tok-comment">//! myapp &quot;This string Value and the int Value after it both belong to the 'myapp' main Command.&quot; 13</span></span>
<span class="line" id="L8"><span class="tok-comment">//!</span></span>
<span class="line" id="L9"><span class="tok-comment">//! # Values belonging to an Option.</span></span>
<span class="line" id="L10"><span class="tok-comment">//! myapp --string_opt &quot;This Value belongs to the 'string_opt' Option.&quot;</span></span>
<span class="line" id="L11"><span class="tok-comment">//! ```</span></span>
<span class="line" id="L12"></span>
<span class="line" id="L13"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L14"><span class="tok-kw">const</span> builtin = std.builtin;</span>
<span class="line" id="L15"><span class="tok-kw">const</span> ascii = std.ascii;</span>
<span class="line" id="L16"><span class="tok-kw">const</span> fmt = std.fmt;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> fs = std.fs;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> log = std.log;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L20"><span class="tok-kw">const</span> meta = std.meta;</span>
<span class="line" id="L21"></span>
<span class="line" id="L22"><span class="tok-kw">const</span> toLower = ascii.lowerString;</span>
<span class="line" id="L23"><span class="tok-kw">const</span> toUpper = ascii.upperString;</span>
<span class="line" id="L24"><span class="tok-kw">const</span> parseInt = fmt.parseInt;</span>
<span class="line" id="L25"><span class="tok-kw">const</span> parseFloat = fmt.parseFloat;</span>
<span class="line" id="L26"><span class="tok-kw">const</span> Type = builtin.Type;</span>
<span class="line" id="L27"></span>
<span class="line" id="L28"><span class="tok-kw">const</span> utils = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;utils.zig&quot;</span>);</span>
<span class="line" id="L29"></span>
<span class="line" id="L30"><span class="tok-comment">/// Config for custom Value types. </span></span>
<span class="line" id="L31"><span class="tok-comment">/// This Config is shared across Typed, Generic, and Custom.</span></span>
<span class="line" id="L32"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Config = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L33">    <span class="tok-comment">/// Default Set Behavior for all Values.</span></span>
<span class="line" id="L34">    <span class="tok-comment">/// This can be overwritten on individual Values using the `Value.Typed.set_behavior` field.</span></span>
<span class="line" id="L35">    global_set_behavior: SetBehavior = .Last,</span>
<span class="line" id="L36">    <span class="tok-comment">/// Default Argument Delimiters for all Values.</span></span>
<span class="line" id="L37">    <span class="tok-comment">/// This can be overwritten on individual Values using the `Value.Typed.arg_delims` field.</span></span>
<span class="line" id="L38">    global_arg_delims: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;,;&quot;</span>,</span>
<span class="line" id="L39">    <span class="tok-comment">/// Maximum instances of a Child Type that a Value can hold.</span></span>
<span class="line" id="L40">    max_children: <span class="tok-type">u8</span> = <span class="tok-number">10</span>,</span>
<span class="line" id="L41"></span>
<span class="line" id="L42">    <span class="tok-comment">/// Custom Types for this project's Custom Values. </span></span>
<span class="line" id="L43">    <span class="tok-comment">/// If these Types are `Value.Typed` they'll be coerced to match the parent `Value.Config` (not preferred).</span></span>
<span class="line" id="L44">    <span class="tok-comment">/// Otherwise, each Type will be wrapped into a `Value.Typed` (preferred).</span></span>
<span class="line" id="L45">    <span class="tok-comment">/// This is useful for adding additional types that aren't covered by the base `Value.Generic` union.</span></span>
<span class="line" id="L46">    <span class="tok-comment">/// Note, any non-numeric (Int, UInt, Float) or non-`Value.Typed` Types will require their own Parse Function.</span></span>
<span class="line" id="L47">    <span class="tok-comment">/// This function is implemented on the `Value.Typed.parse_fn` field.</span></span>
<span class="line" id="L48">    custom_types: []<span class="tok-kw">const</span> <span class="tok-type">type</span> = &amp;.{},</span>
<span class="line" id="L49">    <span class="tok-comment">/// Use the slim base Union. This is automatically treated as true if there are any custom Types specified.</span></span>
<span class="line" id="L50">    <span class="tok-comment">/// This toggle can be used to slim down the base `Value.Generic` Union to only `bool` and `[]const u8` (string).</span></span>
<span class="line" id="L51">    <span class="tok-comment">/// In turn, this will help reduce the overall binary size.</span></span>
<span class="line" id="L52">    <span class="tok-comment">/// Be sure to set `add_base_ints` and `add_base_floats` appropriately as well.</span></span>
<span class="line" id="L53">    use_slim_base: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L54">    <span class="tok-comment">/// Add Base Integers (signed and unsigned) when adding custom Types.</span></span>
<span class="line" id="L55">    <span class="tok-comment">/// This includes `u1`-`u4` directly and `u8`-`u64` by powers of 2, along with their signed counterparts.</span></span>
<span class="line" id="L56">    add_base_ints: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L57">    <span class="tok-comment">/// Add Base Floats when adding custom Types.</span></span>
<span class="line" id="L58">    <span class="tok-comment">/// This includes `f16`, `f32`, and `f64`.</span></span>
<span class="line" id="L59">    add_base_floats: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L60"></span>
<span class="line" id="L61">    <span class="tok-comment">/// Custom Parsing Functions to be used in place of the normal `parse()` for Argument Parsing for all instances of a `Value.Typed` Child Type.</span></span>
<span class="line" id="L62">    <span class="tok-comment">/// These functions will be used SECOND, after an instance's `self.parse_fn` but before the normal `parse()` functions are tried.</span></span>
<span class="line" id="L63">    <span class="tok-comment">/// This can be used to overwrite the `parse()` implementation for an existing Child Type that's already in `Value.Generic`.</span></span>
<span class="line" id="L64">    <span class="tok-comment">/// Note that any error caught from these function will be returned as `error.CannotParseArgToValue`.</span></span>
<span class="line" id="L65">    child_type_parse_fns: ?[]<span class="tok-kw">const</span> <span class="tok-kw">struct</span>{ </span>
<span class="line" id="L66">        <span class="tok-comment">/// The Child Type this function applies to.</span></span>
<span class="line" id="L67">        ChildT: <span class="tok-type">type</span>,</span>
<span class="line" id="L68">        <span class="tok-comment">/// The custom Parse Function.</span></span>
<span class="line" id="L69">        parse_fn: *<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, </span>
<span class="line" id="L70">    } = <span class="tok-null">null</span>,</span>
<span class="line" id="L71"></span>
<span class="line" id="L72">    <span class="tok-comment">/// Custom Child Type Aliases to be used in place of a `Value.Typed`'s actual Child Type name for all instances of the specified Child Type.</span></span>
<span class="line" id="L73">    <span class="tok-comment">/// These aliases will be used SECOND, after an instance's `self.alias_child_type` but before the normal Child Type name is returned.</span></span>
<span class="line" id="L74">    child_type_aliases: ?[]<span class="tok-kw">const</span> <span class="tok-kw">struct</span>{</span>
<span class="line" id="L75">        <span class="tok-comment">/// The Child Type this function applies to.</span></span>
<span class="line" id="L76">        ChildT: <span class="tok-type">type</span>,</span>
<span class="line" id="L77">        <span class="tok-comment">/// The custom Alias.</span></span>
<span class="line" id="L78">        alias: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L79">    } = <span class="tok-null">null</span>,</span>
<span class="line" id="L80"></span>
<span class="line" id="L81">    <span class="tok-comment">/// Use Custom Bit Width Range for Ints and UInts.</span></span>
<span class="line" id="L82">    <span class="tok-comment">/// This is useful for specifying a wide range of Int and UInt types for a project.</span></span>
<span class="line" id="L83">    <span class="tok-comment">/// Note, this will slow down compilation speed!!! (It does not affect runtime speed).</span></span>
<span class="line" id="L84">    use_custom_bit_width_range: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L85">    <span class="tok-comment">/// Minimum Bit Width for Ints and UInts in this Custom Value type.</span></span>
<span class="line" id="L86">    <span class="tok-comment">/// Note, only applies if `use_custom_bit_width_range` is set to `true`.</span></span>
<span class="line" id="L87">    min_int_bit_width: <span class="tok-type">u16</span> = <span class="tok-number">1</span>,</span>
<span class="line" id="L88">    <span class="tok-comment">/// Minimum Bit Width for Ints and UInts in this Custom Value type.</span></span>
<span class="line" id="L89">    <span class="tok-comment">/// Note, only applies if `use_custom_bit_width_range` is set to `true`.</span></span>
<span class="line" id="L90">    max_int_bit_width: <span class="tok-type">u16</span> = <span class="tok-number">256</span>,</span>
<span class="line" id="L91"></span>
<span class="line" id="L92">    <span class="tok-comment">/// A custom Help function to override the default `help()` function globally for ALL Value instances of this custom Value Type.</span></span>
<span class="line" id="L93">    <span class="tok-comment">/// This function is 2nd in precedence.</span></span>
<span class="line" id="L94">    <span class="tok-comment">///</span></span>
<span class="line" id="L95">    <span class="tok-comment">/// Function parameters:</span></span>
<span class="line" id="L96">    <span class="tok-comment">/// 1. ValueT (This should be the `self` parameter. As such it needs to match the Value Type the function is being called on.)</span></span>
<span class="line" id="L97">    <span class="tok-comment">/// 2. Writer (This is the Writer that will written to.)</span></span>
<span class="line" id="L98">    <span class="tok-comment">/// 3. Allocator (This does not have to be used within in the function, but must be supported in case it's needed.)</span></span>
<span class="line" id="L99">    global_help_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(<span class="tok-kw">anytype</span>, <span class="tok-kw">anytype</span>, mem.Allocator)<span class="tok-type">anyerror</span>!<span class="tok-type">void</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L100">    <span class="tok-comment">/// A custom Help function to override the default `usage()` function globally for ALL Value instances of this custom Value Type.</span></span>
<span class="line" id="L101">    <span class="tok-comment">/// This function is 2nd in precedence.</span></span>
<span class="line" id="L102">    <span class="tok-comment">///</span></span>
<span class="line" id="L103">    <span class="tok-comment">/// Function parameters:</span></span>
<span class="line" id="L104">    <span class="tok-comment">/// 1. ValueT (This should be the `self` parameter. As such it needs to match the Value Type the function is being called on.)</span></span>
<span class="line" id="L105">    <span class="tok-comment">/// 2. Writer (This is the Writer that will written to.)</span></span>
<span class="line" id="L106">    <span class="tok-comment">/// 3. Allocator (This does not have to be used within the function, but must be supported in case it's needed.)</span></span>
<span class="line" id="L107">    global_usage_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(<span class="tok-kw">anytype</span>, <span class="tok-kw">anytype</span>, mem.Allocator)<span class="tok-type">anyerror</span>!<span class="tok-type">void</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L108">    <span class="tok-comment">/// Custom Help functions to override the default `help()` function for all Value instances with a matching Child Type.</span></span>
<span class="line" id="L109">    <span class="tok-comment">/// These functions are 1st in precedence.</span></span>
<span class="line" id="L110">    child_type_help_fns: ?[]<span class="tok-kw">const</span> <span class="tok-kw">struct</span>{ </span>
<span class="line" id="L111">        <span class="tok-comment">/// The Child Type this function applies to.</span></span>
<span class="line" id="L112">        ChildT: <span class="tok-type">type</span>,</span>
<span class="line" id="L113">        <span class="tok-comment">/// The custom Help Function.</span></span>
<span class="line" id="L114">        <span class="tok-comment">///</span></span>
<span class="line" id="L115">        <span class="tok-comment">/// Function parameters:</span></span>
<span class="line" id="L116">        <span class="tok-comment">/// 1. ValueT (This should be the `self` parameter. As such it needs to match the Value Type the function is being called on.)</span></span>
<span class="line" id="L117">        <span class="tok-comment">/// 2. Writer (This is the Writer that will written to.)</span></span>
<span class="line" id="L118">        <span class="tok-comment">/// 3. Allocator (This does not have to be used within in the function, but must be supported in case it's needed.)</span></span>
<span class="line" id="L119">        help_fn: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(<span class="tok-kw">anytype</span>, <span class="tok-kw">anytype</span>, mem.Allocator)<span class="tok-type">anyerror</span>!<span class="tok-type">void</span>,</span>
<span class="line" id="L120">    } = <span class="tok-null">null</span>,</span>
<span class="line" id="L121">    <span class="tok-comment">/// Custom Usage functions to override the default `usage()` function for all Value instances with a matching Child Type.</span></span>
<span class="line" id="L122">    <span class="tok-comment">/// These functions are 1st in precedence.</span></span>
<span class="line" id="L123">    child_type_usage_fns: ?[]<span class="tok-kw">const</span> <span class="tok-kw">struct</span>{ </span>
<span class="line" id="L124">        <span class="tok-comment">/// The Child Type this function applies to.</span></span>
<span class="line" id="L125">        ChildT: <span class="tok-type">type</span>,</span>
<span class="line" id="L126">        <span class="tok-comment">/// The custom Usage Function.</span></span>
<span class="line" id="L127">        <span class="tok-comment">///</span></span>
<span class="line" id="L128">        <span class="tok-comment">/// Function parameters:</span></span>
<span class="line" id="L129">        <span class="tok-comment">/// 1. ValueT (This should be the `self` parameter. As such it needs to match the Value Type the function is being called on.)</span></span>
<span class="line" id="L130">        <span class="tok-comment">/// 2. Writer (This is the Writer that will written to.)</span></span>
<span class="line" id="L131">        <span class="tok-comment">/// 3. Allocator (This does not have to be used within in the function, but must be supported in case it's needed.)</span></span>
<span class="line" id="L132">        usage_fn: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(<span class="tok-kw">anytype</span>, <span class="tok-kw">anytype</span>, mem.Allocator)<span class="tok-type">anyerror</span>!<span class="tok-type">void</span>,</span>
<span class="line" id="L133">    } = <span class="tok-null">null</span>,</span>
<span class="line" id="L134"></span>
<span class="line" id="L135">    <span class="tok-comment">/// Indent string used for Usage/Help formatting.</span></span>
<span class="line" id="L136">    <span class="tok-comment">/// Note, if this is left null, it will inherit from the Command Config. </span></span>
<span class="line" id="L137">    indent_fmt: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L138">    <span class="tok-comment">/// Values Usage Format.</span></span>
<span class="line" id="L139">    <span class="tok-comment">/// Must support the following format types in this order:</span></span>
<span class="line" id="L140">    <span class="tok-comment">/// 1. String (Value Name)</span></span>
<span class="line" id="L141">    <span class="tok-comment">/// 2. String (Value Type)</span></span>
<span class="line" id="L142">    vals_usage_fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;\&quot;{s} ({s})\&quot;&quot;</span>,</span>
<span class="line" id="L143">    <span class="tok-comment">/// Values Help Format.</span></span>
<span class="line" id="L144">    <span class="tok-comment">/// Must support the following format types in this order:</span></span>
<span class="line" id="L145">    <span class="tok-comment">/// 1. String (Value Name)</span></span>
<span class="line" id="L146">    <span class="tok-comment">/// 2. String (Value Type)</span></span>
<span class="line" id="L147">    <span class="tok-comment">/// 3. String (Value Description)</span></span>
<span class="line" id="L148">    vals_help_fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;{s} ({s}): {s}&quot;</span>,</span>
<span class="line" id="L149">    </span>
<span class="line" id="L150">};</span>
<span class="line" id="L151"></span>
<span class="line" id="L152"><span class="tok-comment">/// The Behavior for Setting Values with `set()`.</span></span>
<span class="line" id="L153"><span class="tok-comment">/// This applies to Values within Options and standalone Values.</span></span>
<span class="line" id="L154"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetBehavior = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L155">    <span class="tok-comment">/// Keeps the First Argument this Value was `set()` to.</span></span>
<span class="line" id="L156">    First,</span>
<span class="line" id="L157">    <span class="tok-comment">/// Keeps the Last Argument this Value was `set()` to.</span></span>
<span class="line" id="L158">    Last,</span>
<span class="line" id="L159">    <span class="tok-comment">/// Keeps Multiple Arguments in this Value up to the Value's `max_args`.</span></span>
<span class="line" id="L160">    Multi,</span>
<span class="line" id="L161">};</span>
<span class="line" id="L162"></span>
<span class="line" id="L163"><span class="tok-comment">/// Create a Value with a specific Type (`SetT`).</span></span>
<span class="line" id="L164"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Typed</span>(<span class="tok-kw">comptime</span> SetT: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> config: Config) <span class="tok-type">type</span> {</span>
<span class="line" id="L165">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L166">        <span class="tok-comment">/// The Child Type of this Value.</span></span>
<span class="line" id="L167">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChildT = SetT;</span>
<span class="line" id="L168"></span>
<span class="line" id="L169">        <span class="tok-comment">/// An Alias for the Child Type.</span></span>
<span class="line" id="L170">        <span class="tok-comment">/// This is useful for changing the type hint shown in Usage/Help messages or other Generated Docs.</span></span>
<span class="line" id="L171">        alias_child_type: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">        <span class="tok-comment">/// The Allocator for this Value's parent Command.</span></span>
<span class="line" id="L174">        <span class="tok-comment">/// This is set during the `init()` call of this Value's parent Command.</span></span>
<span class="line" id="L175">        <span class="tok-comment">///</span></span>
<span class="line" id="L176">        <span class="tok-comment">/// **Internal Use.**</span></span>
<span class="line" id="L177">        _alloc: ?mem.Allocator = <span class="tok-null">null</span>,</span>
<span class="line" id="L178"></span>
<span class="line" id="L179">        <span class="tok-comment">/// Value Group of this Value.</span></span>
<span class="line" id="L180">        <span class="tok-comment">/// This must line up with one of the Value Groups in the `val_groups` of the parent Command or it will be ignored.</span></span>
<span class="line" id="L181">        <span class="tok-comment">/// This can be Validated using `Command.Custom.ValidateConfig.check_arg_groups`.</span></span>
<span class="line" id="L182">        val_group: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L183"></span>
<span class="line" id="L184">        <span class="tok-comment">/// The Parsed and Validated Argument(s) this Value has been set to.</span></span>
<span class="line" id="L185">        <span class="tok-comment">///</span></span>
<span class="line" id="L186">        <span class="tok-comment">/// **Internal Use.**</span></span>
<span class="line" id="L187">        _set_args: [config.max_children]?ChildT = .{ <span class="tok-null">null</span> } ** config.max_children,</span>
<span class="line" id="L188">        <span class="tok-comment">/// The current Index of Raw Arguments for this Value.</span></span>
<span class="line" id="L189">        <span class="tok-comment">///</span></span>
<span class="line" id="L190">        <span class="tok-comment">/// **Internal Use.**</span></span>
<span class="line" id="L191">        _arg_idx: <span class="tok-type">u7</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L192">        <span class="tok-comment">/// The Max number of Raw Arguments that can be provided.</span></span>
<span class="line" id="L193">        <span class="tok-comment">/// This must be between 1 to the value of `config.max_children`.</span></span>
<span class="line" id="L194">        max_args: <span class="tok-type">u7</span> = <span class="tok-number">1</span>,</span>
<span class="line" id="L195">        <span class="tok-comment">/// Flag to determine if this Value is at max capacity for Raw Arguments.</span></span>
<span class="line" id="L196">        <span class="tok-comment">///</span></span>
<span class="line" id="L197">        <span class="tok-comment">/// *This should be Read-Only for library users.*</span></span>
<span class="line" id="L198">        is_maxed: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L199">        <span class="tok-comment">/// Delimiter Characters that can be used to split up Multi-Values or Multi-Options.</span></span>
<span class="line" id="L200">        <span class="tok-comment">/// This is only applicable if `set_behavior = .Multi`.</span></span>
<span class="line" id="L201">        arg_delims: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = config.global_arg_delims,</span>
<span class="line" id="L202">        <span class="tok-comment">/// Set Behavior for this Value.</span></span>
<span class="line" id="L203">        set_behavior: SetBehavior = config.global_set_behavior,</span>
<span class="line" id="L204">        <span class="tok-comment">/// An optional Default value for this Value.</span></span>
<span class="line" id="L205">        default_val: ?ChildT = <span class="tok-null">null</span>,</span>
<span class="line" id="L206">        <span class="tok-comment">/// Flag to determine if this Value has been Parsed and Validated.</span></span>
<span class="line" id="L207">        <span class="tok-comment">///</span></span>
<span class="line" id="L208">        <span class="tok-comment">/// *This should be Read-Only for library users.*</span></span>
<span class="line" id="L209">        is_set: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L210"></span>
<span class="line" id="L211">        <span class="tok-comment">/// A Parsing Function to be used in place of the normal `parse()` for Argument Parsing for this specific Value.</span></span>
<span class="line" id="L212">        <span class="tok-comment">/// This will be used FIRST, before `type_parse_fn` then the normal `parse()` functions are tried.</span></span>
<span class="line" id="L213">        <span class="tok-comment">/// Note that any error caught from this function will be returned as `error.CannotParseArgToValue`.</span></span>
<span class="line" id="L214">        parse_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mem.Allocator) <span class="tok-type">anyerror</span>!ChildT = <span class="tok-null">null</span>,</span>
<span class="line" id="L215">        <span class="tok-comment">/// A Validation Function to be used for Argument Validation in `set()` following Argument Parsing with `parse()`.</span></span>
<span class="line" id="L216">        valid_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(ChildT, mem.Allocator) <span class="tok-type">bool</span> = <span class="tok-null">null</span>, </span>
<span class="line" id="L217">            </span>
<span class="line" id="L218">        <span class="tok-comment">/// The Name of this Value for user identification and Usage/Help messages.</span></span>
<span class="line" id="L219">        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L220">        <span class="tok-comment">/// The Description of this Value for Usage/Help messages.</span></span>
<span class="line" id="L221">        description: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L222"></span>
<span class="line" id="L223">        <span class="tok-comment">/// Custom Parsing function for this Value Type.</span></span>
<span class="line" id="L224">        <span class="tok-comment">/// Check `Value.Config` for details.</span></span>
<span class="line" id="L225">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> child_type_parse_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mem.Allocator) <span class="tok-type">anyerror</span>!ChildT = typeParseFn: {</span>
<span class="line" id="L226">            <span class="tok-kw">for</span> (config.child_type_parse_fns <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :typeParseFn <span class="tok-null">null</span>) |elm| {</span>
<span class="line" id="L227">                <span class="tok-kw">if</span> (elm.ChildT == SetT) <span class="tok-kw">break</span> :typeParseFn <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mem.Allocator) <span class="tok-type">anyerror</span>!ChildT, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(elm.parse_fn)));</span>
<span class="line" id="L228">            }</span>
<span class="line" id="L229">            <span class="tok-kw">else</span> <span class="tok-kw">break</span> :typeParseFn <span class="tok-null">null</span>;</span>
<span class="line" id="L230">        };</span>
<span class="line" id="L231"></span>
<span class="line" id="L232">        <span class="tok-comment">/// Custom Help function for this Value Type.</span></span>
<span class="line" id="L233">        <span class="tok-comment">/// Check `Value.Config` for details.</span></span>
<span class="line" id="L234">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> child_type_help_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mem.Allocator) <span class="tok-type">anyerror</span>!ChildT = typeHelpFn: {</span>
<span class="line" id="L235">            <span class="tok-kw">for</span> (config.child_type_help_fns <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :typeHelpFn <span class="tok-null">null</span>) |elm| {</span>
<span class="line" id="L236">                <span class="tok-kw">if</span> (elm.ChildT == SetT) <span class="tok-kw">break</span> :typeHelpFn <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(<span class="tok-kw">anytype</span>, <span class="tok-kw">anytype</span>, mem.Allocator) <span class="tok-type">anyerror</span>!ChildT, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(elm.help_fn)));</span>
<span class="line" id="L237">            }</span>
<span class="line" id="L238">            <span class="tok-kw">else</span> <span class="tok-kw">break</span> :typeHelpFn <span class="tok-null">null</span>;</span>
<span class="line" id="L239">        };</span>
<span class="line" id="L240">        <span class="tok-comment">/// Custom Usage function for this Value Type.</span></span>
<span class="line" id="L241">        <span class="tok-comment">/// Check `Value.Config` for details.</span></span>
<span class="line" id="L242">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> child_type_usage_fn: ?*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mem.Allocator) <span class="tok-type">anyerror</span>!ChildT = typeUsageFn: {</span>
<span class="line" id="L243">            <span class="tok-kw">for</span> (config.child_type_usage_fns <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :typeUsageFn <span class="tok-null">null</span>) |elm| {</span>
<span class="line" id="L244">                <span class="tok-kw">if</span> (elm.ChildT == SetT) <span class="tok-kw">break</span> :typeUsageFn <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-kw">fn</span>(<span class="tok-kw">anytype</span>, <span class="tok-kw">anytype</span>, mem.Allocator) <span class="tok-type">anyerror</span>!ChildT, <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(elm.usage_fn)));</span>
<span class="line" id="L245">            }</span>
<span class="line" id="L246">            <span class="tok-kw">else</span> <span class="tok-kw">break</span> :typeUsageFn <span class="tok-null">null</span>;</span>
<span class="line" id="L247">        };</span>
<span class="line" id="L248"></span>
<span class="line" id="L249">        <span class="tok-comment">/// Parse the given argument token (`arg`) to this Value's Type.</span></span>
<span class="line" id="L250">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !ChildT {</span>
<span class="line" id="L251">            <span class="tok-kw">if</span> (self.parse_fn) |parseFn| <span class="tok-kw">return</span> parseFn(arg, self._alloc <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNotInitialized) <span class="tok-kw">catch</span> <span class="tok-kw">error</span>.CannotParseArgToValue;</span>
<span class="line" id="L252">            <span class="tok-kw">if</span> (child_type_parse_fn) |parseFn| <span class="tok-kw">return</span> parseFn(arg, self._alloc <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNotInitialized) <span class="tok-kw">catch</span> <span class="tok-kw">error</span>.CannotParseArgToValue;</span>
<span class="line" id="L253">            <span class="tok-kw">var</span> san_arg_buf: [<span class="tok-number">512</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L254">            <span class="tok-kw">const</span> san_arg = toLower(san_arg_buf[<span class="tok-number">0</span>..], arg);</span>
<span class="line" id="L255">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(ChildT)) {</span>
<span class="line" id="L256">                .Bool =&gt; isTrue: {</span>
<span class="line" id="L257">                    <span class="tok-kw">const</span> true_words = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;true&quot;</span>, <span class="tok-str">&quot;t&quot;</span>, <span class="tok-str">&quot;yes&quot;</span>, <span class="tok-str">&quot;y&quot;</span>, <span class="tok-str">&quot;1&quot;</span> };</span>
<span class="line" id="L258">                    <span class="tok-kw">for</span> (true_words[<span class="tok-number">0</span>..]) |word| { <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, word, san_arg)) <span class="tok-kw">break</span> :isTrue <span class="tok-null">true</span>; } <span class="tok-kw">else</span> <span class="tok-kw">break</span> :isTrue <span class="tok-null">false</span>;</span>
<span class="line" id="L259">                },</span>
<span class="line" id="L260">                .Pointer =&gt; arg,</span>
<span class="line" id="L261">                .Int =&gt; parseInt(ChildT, arg, <span class="tok-number">0</span>),</span>
<span class="line" id="L262">                .Float =&gt; parseFloat(ChildT, arg),</span>
<span class="line" id="L263">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>.CannotParseArgToValue,</span>
<span class="line" id="L264">            };</span>
<span class="line" id="L265">        }</span>
<span class="line" id="L266"></span>
<span class="line" id="L267">        <span class="tok-comment">/// Set this Value if the provided argument token (`set_arg`) can be Parsed and Validated.</span></span>
<span class="line" id="L268">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), set_arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L269">            <span class="tok-comment">// Delimited Args</span>
</span>
<span class="line" id="L270">            <span class="tok-kw">var</span> arg_delim: <span class="tok-type">u8</span> = <span class="tok-str">' '</span>;</span>
<span class="line" id="L271">            <span class="tok-kw">const</span> check_delim: <span class="tok-type">bool</span> = checkDelim: {</span>
<span class="line" id="L272">                <span class="tok-kw">for</span> (self.arg_delims) |delim| {</span>
<span class="line" id="L273">                    <span class="tok-kw">if</span> (mem.indexOfScalar(<span class="tok-type">u8</span>, set_arg, delim) != <span class="tok-null">null</span>) {</span>
<span class="line" id="L274">                        arg_delim = delim;</span>
<span class="line" id="L275">                        <span class="tok-kw">break</span> :checkDelim <span class="tok-null">true</span>;</span>
<span class="line" id="L276">                    }</span>
<span class="line" id="L277">                }</span>
<span class="line" id="L278">                <span class="tok-kw">break</span> :checkDelim <span class="tok-null">false</span>;</span>
<span class="line" id="L279">            };</span>
<span class="line" id="L280">            <span class="tok-kw">if</span> (self.set_behavior == .Multi <span class="tok-kw">and</span> meta.activeTag(<span class="tok-builtin">@typeInfo</span>(ChildT)) != .Pointer <span class="tok-kw">and</span> check_delim) {</span>
<span class="line" id="L281">                <span class="tok-kw">var</span> split_args = mem.splitScalar(<span class="tok-type">u8</span>, set_arg, arg_delim);</span>
<span class="line" id="L282">                <span class="tok-kw">while</span> (split_args.next()) |arg| <span class="tok-kw">try</span> self.set(arg);</span>
<span class="line" id="L283">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L284">            }</span>
<span class="line" id="L285"></span>
<span class="line" id="L286">            <span class="tok-comment">// Single Arg</span>
</span>
<span class="line" id="L287">            <span class="tok-kw">const</span> parsed_arg = <span class="tok-kw">try</span> self.parse(set_arg);</span>
<span class="line" id="L288">            <span class="tok-builtin">@constCast</span>(self).is_set =</span>
<span class="line" id="L289">                <span class="tok-kw">if</span> (self.valid_fn) |validFn| validFn(parsed_arg, self._alloc <span class="tok-kw">orelse</span> { </span>
<span class="line" id="L290">                    log.err(<span class="tok-str">&quot;The Value '{s}' does not have an Allocator!&quot;</span>, .{ self.name }); </span>
<span class="line" id="L291">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNotInitialized; }</span>
<span class="line" id="L292">                )</span>
<span class="line" id="L293">                <span class="tok-kw">else</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L294">            <span class="tok-kw">if</span> (self.is_set) {</span>
<span class="line" id="L295">                <span class="tok-kw">switch</span> (self.set_behavior) {</span>
<span class="line" id="L296">                    .First =&gt; <span class="tok-kw">if</span> (self._set_args[<span class="tok-number">0</span>] == <span class="tok-null">null</span>) { </span>
<span class="line" id="L297">                        <span class="tok-builtin">@constCast</span>(self)._set_args[<span class="tok-number">0</span>] = parsed_arg;</span>
<span class="line" id="L298">                        <span class="tok-builtin">@constCast</span>(self)._arg_idx += <span class="tok-number">1</span>;</span>
<span class="line" id="L299">                    },</span>
<span class="line" id="L300">                    .Last =&gt; {</span>
<span class="line" id="L301">                        <span class="tok-builtin">@constCast</span>(self)._set_args[<span class="tok-number">0</span>] = parsed_arg;</span>
<span class="line" id="L302">                        <span class="tok-kw">if</span> (self._arg_idx &lt; <span class="tok-number">1</span>) <span class="tok-builtin">@constCast</span>(self)._arg_idx += <span class="tok-number">1</span>;</span>
<span class="line" id="L303">                    },</span>
<span class="line" id="L304">                    .Multi =&gt; <span class="tok-kw">if</span> (self._arg_idx &lt; self.max_args) {</span>
<span class="line" id="L305">                        <span class="tok-builtin">@constCast</span>(self)._set_args[self._arg_idx] = parsed_arg;</span>
<span class="line" id="L306">                        <span class="tok-builtin">@constCast</span>(self)._arg_idx += <span class="tok-number">1</span>;</span>
<span class="line" id="L307">                    }</span>
<span class="line" id="L308">                }</span>
<span class="line" id="L309">                <span class="tok-builtin">@constCast</span>(self).is_maxed = self._arg_idx == self.max_args;</span>
<span class="line" id="L310">            }</span>
<span class="line" id="L311">            <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidValue;</span>
<span class="line" id="L312">        }</span>
<span class="line" id="L313"></span>
<span class="line" id="L314">        <span class="tok-comment">/// Get the first Parsed and Validated value of this Value.</span></span>
<span class="line" id="L315">        <span class="tok-comment">/// This will pull the first value from `_set_args` and should be used with the `First` or `Last` Set Behaviors.</span></span>
<span class="line" id="L316">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) !ChildT {</span>
<span class="line" id="L317">            <span class="tok-kw">return</span> </span>
<span class="line" id="L318">                <span class="tok-kw">if</span> (self.is_set) self._set_args[<span class="tok-number">0</span>].?</span>
<span class="line" id="L319">                <span class="tok-kw">else</span> <span class="tok-kw">if</span> (self.default_val) |def_val| def_val</span>
<span class="line" id="L320">                <span class="tok-kw">else</span> <span class="tok-kw">if</span> (ChildT == <span class="tok-type">bool</span>) <span class="tok-null">false</span></span>
<span class="line" id="L321">                <span class="tok-kw">else</span> <span class="tok-kw">error</span>.ValueNotSet;</span>
<span class="line" id="L322">        }</span>
<span class="line" id="L323"></span>
<span class="line" id="L324">        <span class="tok-comment">/// Get All Parsed and Validated Arguments of this Value.</span></span>
<span class="line" id="L325">        <span class="tok-comment">/// This will pull All values from `_set_args` and should be used with `Multi` Set Behavior.</span></span>
<span class="line" id="L326">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAll</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), alloc: mem.Allocator) ![]ChildT {</span>
<span class="line" id="L327">            <span class="tok-kw">if</span> (!self.is_set) {</span>
<span class="line" id="L328">                <span class="tok-kw">if</span> (self.default_val) |def_val| {</span>
<span class="line" id="L329">                    <span class="tok-kw">var</span> val = <span class="tok-kw">try</span> alloc.alloc(ChildT, <span class="tok-number">1</span>);</span>
<span class="line" id="L330">                    val[<span class="tok-number">0</span>] = def_val;</span>
<span class="line" id="L331">                    <span class="tok-kw">return</span> val;</span>
<span class="line" id="L332">                }</span>
<span class="line" id="L333">                <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNotSet;</span>
<span class="line" id="L334">            }</span>
<span class="line" id="L335">            <span class="tok-kw">var</span> vals = <span class="tok-kw">try</span> alloc.alloc(ChildT, self._arg_idx);</span>
<span class="line" id="L336">            <span class="tok-kw">for</span> (self._set_args[<span class="tok-number">0</span>..self._arg_idx], <span class="tok-number">0</span>..) |arg, idx| vals[idx] = arg.?;</span>
<span class="line" id="L337">            <span class="tok-kw">return</span> vals;</span>
<span class="line" id="L338">        }</span>
<span class="line" id="L339"></span>
<span class="line" id="L340">        <span class="tok-comment">/// Initialize this Value with the provided Allocator (`alloc`).</span></span>
<span class="line" id="L341">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), alloc: mem.Allocator) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L342">            <span class="tok-kw">var</span> val = self.*;</span>
<span class="line" id="L343">            val._alloc = alloc;</span>
<span class="line" id="L344">            <span class="tok-kw">return</span> val;</span>
<span class="line" id="L345">        }</span>
<span class="line" id="L346">    };</span>
<span class="line" id="L347">}</span>
<span class="line" id="L348"></span>
<span class="line" id="L349"><span class="tok-comment">/// Generic Value to handle a Value regardless of its inner Child Type. </span></span>
<span class="line" id="L350"><span class="tok-comment">/// This encompasses Typed Values with Boolean, String `[]const u8`, Floats, and the Config (`config`) specified Types.</span></span>
<span class="line" id="L351"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Generic</span>(<span class="tok-kw">comptime</span> config: Config) <span class="tok-type">type</span> {</span>
<span class="line" id="L352">    <span class="tok-comment">// Base Implementation</span>
</span>
<span class="line" id="L353">    <span class="tok-kw">const</span> slim_base = config.use_slim_base <span class="tok-kw">or</span> config.custom_types.len &gt; <span class="tok-number">0</span>;</span>
<span class="line" id="L354">    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (!slim_base <span class="tok-kw">and</span> !config.use_custom_bit_width_range) <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>){</span>
<span class="line" id="L355">        <span class="tok-type">bool</span>: Typed(<span class="tok-type">bool</span>, config),</span>
<span class="line" id="L356">        </span>
<span class="line" id="L357">        string: Typed([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, config),</span>
<span class="line" id="L358">        </span>
<span class="line" id="L359">        <span class="tok-type">u1</span>: Typed(<span class="tok-type">u1</span>, config),</span>
<span class="line" id="L360">        <span class="tok-type">u2</span>: Typed(<span class="tok-type">u2</span>, config),</span>
<span class="line" id="L361">        <span class="tok-type">u3</span>: Typed(<span class="tok-type">u3</span>, config),</span>
<span class="line" id="L362">        <span class="tok-type">u4</span>: Typed(<span class="tok-type">u4</span>, config),</span>
<span class="line" id="L363">        <span class="tok-type">u8</span>: Typed(<span class="tok-type">u8</span>, config),</span>
<span class="line" id="L364">        <span class="tok-type">u16</span>: Typed(<span class="tok-type">u16</span>, config),</span>
<span class="line" id="L365">        <span class="tok-type">u32</span>: Typed(<span class="tok-type">u32</span>, config),</span>
<span class="line" id="L366">        <span class="tok-type">u64</span>: Typed(<span class="tok-type">u64</span>, config),</span>
<span class="line" id="L367">        <span class="tok-comment">//u128: Typed(u128, config),</span>
</span>
<span class="line" id="L368">        <span class="tok-comment">//u256: Typed(u256, config),</span>
</span>
<span class="line" id="L369"></span>
<span class="line" id="L370">        <span class="tok-type">i1</span>: Typed(<span class="tok-type">i1</span>, config),</span>
<span class="line" id="L371">        <span class="tok-type">i2</span>: Typed(<span class="tok-type">i2</span>, config),</span>
<span class="line" id="L372">        <span class="tok-type">i3</span>: Typed(<span class="tok-type">i3</span>, config),</span>
<span class="line" id="L373">        <span class="tok-type">i4</span>: Typed(<span class="tok-type">i4</span>, config),</span>
<span class="line" id="L374">        <span class="tok-type">i8</span>: Typed(<span class="tok-type">i8</span>, config),</span>
<span class="line" id="L375">        <span class="tok-type">i16</span>: Typed(<span class="tok-type">i16</span>, config),</span>
<span class="line" id="L376">        <span class="tok-type">i32</span>: Typed(<span class="tok-type">i32</span>, config),</span>
<span class="line" id="L377">        <span class="tok-type">i64</span>: Typed(<span class="tok-type">i64</span>, config),</span>
<span class="line" id="L378">        <span class="tok-comment">//i128: Typed(i128, config),</span>
</span>
<span class="line" id="L379">        <span class="tok-comment">//i256: Typed(i256, config),</span>
</span>
<span class="line" id="L380"></span>
<span class="line" id="L381">        <span class="tok-type">f16</span>: Typed(<span class="tok-type">f16</span>, config),</span>
<span class="line" id="L382">        <span class="tok-type">f32</span>: Typed(<span class="tok-type">f32</span>, config),</span>
<span class="line" id="L383">        <span class="tok-type">f64</span>: Typed(<span class="tok-type">f64</span>, config),</span>
<span class="line" id="L384">        <span class="tok-comment">//f128: Typed(f128, config),</span>
</span>
<span class="line" id="L385">    }</span>
<span class="line" id="L386">    <span class="tok-comment">// Custom Implementation</span>
</span>
<span class="line" id="L387">    <span class="tok-kw">else</span> customUnion: { </span>
<span class="line" id="L388">        <span class="tok-kw">const</span> base_union = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>){</span>
<span class="line" id="L389">            <span class="tok-type">bool</span>: Typed(<span class="tok-type">bool</span>, config),</span>
<span class="line" id="L390">            string: Typed([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, config),</span>
<span class="line" id="L391">        };</span>
<span class="line" id="L392">        </span>
<span class="line" id="L393">        <span class="tok-kw">var</span> union_info = <span class="tok-builtin">@typeInfo</span>(base_union).Union;</span>
<span class="line" id="L394">        <span class="tok-kw">var</span> tag_info = <span class="tok-builtin">@typeInfo</span>(union_info.tag_type.?).Enum;</span>
<span class="line" id="L395">        tag_info.tag_type = <span class="tok-type">usize</span>;</span>
<span class="line" id="L396">        <span class="tok-kw">if</span> (config.use_custom_bit_width_range) {</span>
<span class="line" id="L397">            <span class="tok-builtin">@setEvalBranchQuota</span>(config.max_int_bit_width * <span class="tok-number">10</span>);</span>
<span class="line" id="L398">            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (config.min_int_bit_width..config.max_int_bit_width) |bit_width| {</span>
<span class="line" id="L399">                <span class="tok-kw">const</span> uint_name = <span class="tok-builtin">@typeName</span>(meta.Int(.unsigned, bit_width));</span>
<span class="line" id="L400">                <span class="tok-kw">const</span> uint_type = Typed(meta.Int(.unsigned, bit_width), config);</span>
<span class="line" id="L401">                union_info.fields = union_info.fields ++ .{ .{</span>
<span class="line" id="L402">                   .name = uint_name, </span>
<span class="line" id="L403">                   .<span class="tok-type">type</span> = uint_type,</span>
<span class="line" id="L404">                   .alignment = <span class="tok-builtin">@alignOf</span>(uint_type),</span>
<span class="line" id="L405">                } };</span>
<span class="line" id="L406">                tag_info.fields = tag_info.fields ++ .{ .{</span>
<span class="line" id="L407">                    .name = uint_name,</span>
<span class="line" id="L408">                    .value = tag_info.fields.len</span>
<span class="line" id="L409">                } };</span>
<span class="line" id="L410"></span>
<span class="line" id="L411">                <span class="tok-kw">const</span> int_name = <span class="tok-builtin">@typeName</span>(meta.Int(.signed, bit_width));</span>
<span class="line" id="L412">                <span class="tok-kw">const</span> int_type = Typed(meta.Int(.signed, bit_width), config);</span>
<span class="line" id="L413">                union_info.fields = union_info.fields ++ .{ .{</span>
<span class="line" id="L414">                   .name = int_name,</span>
<span class="line" id="L415">                   .<span class="tok-type">type</span> = int_type, </span>
<span class="line" id="L416">                   .alignment = <span class="tok-builtin">@alignOf</span>(int_type),</span>
<span class="line" id="L417">                } };</span>
<span class="line" id="L418">                tag_info.fields = tag_info.fields ++ .{ .{</span>
<span class="line" id="L419">                    .name = int_name,</span>
<span class="line" id="L420">                    .value = tag_info.fields.len</span>
<span class="line" id="L421">                } };</span>
<span class="line" id="L422">            }</span>
<span class="line" id="L423">        }</span>
<span class="line" id="L424">        <span class="tok-kw">else</span> {</span>
<span class="line" id="L425">            <span class="tok-kw">if</span> (config.add_base_ints) {</span>
<span class="line" id="L426">                <span class="tok-kw">const</span> int_union = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L427">                    <span class="tok-type">u1</span>: Typed(<span class="tok-type">u1</span>, config),</span>
<span class="line" id="L428">                    <span class="tok-type">u2</span>: Typed(<span class="tok-type">u2</span>, config),</span>
<span class="line" id="L429">                    <span class="tok-type">u3</span>: Typed(<span class="tok-type">u3</span>, config),</span>
<span class="line" id="L430">                    <span class="tok-type">u4</span>: Typed(<span class="tok-type">u4</span>, config),</span>
<span class="line" id="L431">                    <span class="tok-type">u8</span>: Typed(<span class="tok-type">u8</span>, config),</span>
<span class="line" id="L432">                    <span class="tok-type">u16</span>: Typed(<span class="tok-type">u16</span>, config),</span>
<span class="line" id="L433">                    <span class="tok-type">u32</span>: Typed(<span class="tok-type">u32</span>, config),</span>
<span class="line" id="L434">                    <span class="tok-type">u64</span>: Typed(<span class="tok-type">u64</span>, config),</span>
<span class="line" id="L435">                    <span class="tok-comment">//u128: Typed(u128, config),</span>
</span>
<span class="line" id="L436">                    <span class="tok-comment">//u256: Typed(u256, config),</span>
</span>
<span class="line" id="L437"></span>
<span class="line" id="L438">                    <span class="tok-type">i1</span>: Typed(<span class="tok-type">i1</span>, config),</span>
<span class="line" id="L439">                    <span class="tok-type">i2</span>: Typed(<span class="tok-type">i2</span>, config),</span>
<span class="line" id="L440">                    <span class="tok-type">i3</span>: Typed(<span class="tok-type">i3</span>, config),</span>
<span class="line" id="L441">                    <span class="tok-type">i4</span>: Typed(<span class="tok-type">i4</span>, config),</span>
<span class="line" id="L442">                    <span class="tok-type">i8</span>: Typed(<span class="tok-type">i8</span>, config),</span>
<span class="line" id="L443">                    <span class="tok-type">i16</span>: Typed(<span class="tok-type">i16</span>, config),</span>
<span class="line" id="L444">                    <span class="tok-type">i32</span>: Typed(<span class="tok-type">i32</span>, config),</span>
<span class="line" id="L445">                    <span class="tok-type">i64</span>: Typed(<span class="tok-type">i64</span>, config),</span>
<span class="line" id="L446">                    <span class="tok-comment">//i128: Typed(i128, config),</span>
</span>
<span class="line" id="L447">                    <span class="tok-comment">//i256: Typed(i256, config),</span>
</span>
<span class="line" id="L448">                };</span>
<span class="line" id="L449">                <span class="tok-kw">const</span> int_info = <span class="tok-builtin">@typeInfo</span>(int_union).Union;</span>
<span class="line" id="L450">                <span class="tok-kw">const</span> int_tag_info = <span class="tok-builtin">@typeInfo</span>(int_info.tag_type.?).Enum;</span>
<span class="line" id="L451"></span>
<span class="line" id="L452">                union_info.fields = union_info.fields ++ int_info.fields;</span>
<span class="line" id="L453">                <span class="tok-kw">for</span> (int_tag_info.fields) |tag| {</span>
<span class="line" id="L454">                    tag_info.fields = tag_info.fields ++ .{ .{</span>
<span class="line" id="L455">                        .name = tag.name,</span>
<span class="line" id="L456">                        .value = tag.value + <span class="tok-number">2</span>,</span>
<span class="line" id="L457">                    } };</span>
<span class="line" id="L458">                }</span>
<span class="line" id="L459">            }</span>
<span class="line" id="L460">            <span class="tok-kw">if</span> (config.add_base_floats) {</span>
<span class="line" id="L461">                <span class="tok-kw">const</span> float_union = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L462">                    <span class="tok-type">f16</span>: Typed(<span class="tok-type">f16</span>, config),</span>
<span class="line" id="L463">                    <span class="tok-type">f32</span>: Typed(<span class="tok-type">f32</span>, config),</span>
<span class="line" id="L464">                    <span class="tok-type">f64</span>: Typed(<span class="tok-type">f64</span>, config),</span>
<span class="line" id="L465">                    <span class="tok-comment">//f128: Typed(f128, config),</span>
</span>
<span class="line" id="L466">                };</span>
<span class="line" id="L467">                <span class="tok-kw">const</span> float_info = <span class="tok-builtin">@typeInfo</span>(float_union).Union;</span>
<span class="line" id="L468">                <span class="tok-kw">const</span> float_tag_info = <span class="tok-builtin">@typeInfo</span>(float_info.tag_type.?).Enum;</span>
<span class="line" id="L469"></span>
<span class="line" id="L470">                <span class="tok-kw">const</span> add_val = <span class="tok-kw">if</span> (config.add_base_ints) <span class="tok-number">18</span> <span class="tok-kw">else</span> <span class="tok-number">2</span>;</span>
<span class="line" id="L471">                union_info.fields = union_info.fields ++ float_info.fields;</span>
<span class="line" id="L472">                <span class="tok-kw">for</span> (float_tag_info.fields) |tag| {</span>
<span class="line" id="L473">                    tag_info.fields = tag_info.fields ++ .{ .{</span>
<span class="line" id="L474">                        .name = tag.name,</span>
<span class="line" id="L475">                        .value = tag.value + add_val,</span>
<span class="line" id="L476">                    } };</span>
<span class="line" id="L477">                }</span>
<span class="line" id="L478">            }</span>
<span class="line" id="L479">        }</span>
<span class="line" id="L480"></span>
<span class="line" id="L481">        <span class="tok-kw">var</span> adds: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L482">        <span class="tok-kw">for</span> (config.custom_types) |T| {</span>
<span class="line" id="L483">            <span class="tok-kw">const</span> AddT = addT: {</span>
<span class="line" id="L484">                <span class="tok-kw">const</span> add_info = <span class="tok-builtin">@typeInfo</span>(T);</span>
<span class="line" id="L485">                <span class="tok-kw">switch</span> (add_info) {</span>
<span class="line" id="L486">                    <span class="tok-comment">// Check for `Value.Typed`</span>
</span>
<span class="line" id="L487">                    .Struct =&gt; |struct_info| {</span>
<span class="line" id="L488">                        <span class="tok-kw">const</span> base_fields = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(Typed(<span class="tok-type">bool</span>, config){})).Struct.fields;</span>
<span class="line" id="L489">                        <span class="tok-kw">if</span> (struct_info.fields.len != base_fields.len) <span class="tok-kw">break</span> :addT Typed(T, config);</span>
<span class="line" id="L490">                        <span class="tok-kw">for</span> (struct_info.fields, base_fields) |a_field, b_field| {</span>
<span class="line" id="L491">                            <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, a_field.name, b_field.name)) <span class="tok-kw">break</span> :addT Typed(T, config);</span>
<span class="line" id="L492">                        }</span>
<span class="line" id="L493">                        <span class="tok-kw">break</span> :addT Typed(T.ChildT, config);</span>
<span class="line" id="L494">                    },</span>
<span class="line" id="L495">                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :addT Typed(T, config),</span>
<span class="line" id="L496">                }</span>
<span class="line" id="L497">            };</span>
<span class="line" id="L498">            <span class="tok-kw">const</span> union_field = Type.UnionField{</span>
<span class="line" id="L499">               .name = <span class="tok-builtin">@typeName</span>(AddT.ChildT), </span>
<span class="line" id="L500">               .<span class="tok-type">type</span> = AddT,</span>
<span class="line" id="L501">               .alignment = <span class="tok-builtin">@alignOf</span>(AddT),</span>
<span class="line" id="L502">            };</span>
<span class="line" id="L503">            <span class="tok-kw">const</span> union_tag = Type.EnumField{</span>
<span class="line" id="L504">                .name = <span class="tok-builtin">@typeName</span>(AddT.ChildT),</span>
<span class="line" id="L505">                .value = tag_info.fields.len + adds,</span>
<span class="line" id="L506">            };</span>
<span class="line" id="L507">            <span class="tok-kw">for</span> (union_info.fields, <span class="tok-number">0</span>..) |field, idx| {</span>
<span class="line" id="L508">                <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, field.name, union_field.name)) <span class="tok-kw">continue</span>;</span>
<span class="line" id="L509">                adds += <span class="tok-number">1</span>;</span>
<span class="line" id="L510">                union_info.fields = rebuildFields: {</span>
<span class="line" id="L511">                    <span class="tok-kw">var</span> rebuild: [union_info.fields.len]Type.UnionField = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L512">                    <span class="tok-kw">for</span> (rebuild[<span class="tok-number">0</span>..], union_info.fields, <span class="tok-number">0</span>..) |*r_fld, o_fld, r_idx|</span>
<span class="line" id="L513">                       r_fld.* = <span class="tok-kw">if</span> (r_idx == idx) union_field <span class="tok-kw">else</span> o_fld;</span>
<span class="line" id="L514">                    <span class="tok-kw">break</span> :rebuildFields rebuild[<span class="tok-number">0</span>..]; <span class="tok-comment">// Scope lifetime issue??</span>
</span>
<span class="line" id="L515">                };    </span>
<span class="line" id="L516">                tag_info.fields = rebuildFields: {</span>
<span class="line" id="L517">                    <span class="tok-kw">var</span> rebuild: [tag_info.fields.len]Type.EnumField = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L518">                    <span class="tok-kw">for</span> (rebuild[<span class="tok-number">0</span>..], tag_info.fields, <span class="tok-number">0</span>..) |*r_fld, o_fld, r_idx|</span>
<span class="line" id="L519">                       r_fld.* = <span class="tok-kw">if</span> (r_idx == idx) union_tag <span class="tok-kw">else</span> o_fld;</span>
<span class="line" id="L520">                    <span class="tok-kw">break</span> :rebuildFields rebuild[<span class="tok-number">0</span>..]; <span class="tok-comment">// Scope lifetime issue??</span>
</span>
<span class="line" id="L521">                };    </span>
<span class="line" id="L522">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L523">            }</span>
<span class="line" id="L524">            <span class="tok-kw">else</span> {</span>
<span class="line" id="L525">                union_info.fields = union_info.fields ++ .{ union_field };</span>
<span class="line" id="L526">                tag_info.fields = tag_info.fields ++ .{ union_tag };</span>
<span class="line" id="L527">            }</span>
<span class="line" id="L528">            </span>
<span class="line" id="L529">        }</span>
<span class="line" id="L530"></span>
<span class="line" id="L531">        union_info.tag_type = <span class="tok-builtin">@Type</span>(.{ .Enum = tag_info }); </span>
<span class="line" id="L532">        <span class="tok-kw">break</span> :customUnion <span class="tok-builtin">@Type</span>(.{ .Union = union_info });</span>
<span class="line" id="L533">    };</span>
<span class="line" id="L534">}</span>
<span class="line" id="L535"></span>
<span class="line" id="L536"><span class="tok-comment">/// Create a Custom Value type from the provided Config (`config`).</span></span>
<span class="line" id="L537"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Custom</span>(<span class="tok-kw">comptime</span> config: Config) <span class="tok-type">type</span> {</span>
<span class="line" id="L538">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span>{</span>
<span class="line" id="L539">        <span class="tok-comment">/// Custom Generic Value type.</span></span>
<span class="line" id="L540">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GenericT = Generic(config);</span>
<span class="line" id="L541"></span>
<span class="line" id="L542">        <span class="tok-comment">/// Wrapped Generic Value union.</span></span>
<span class="line" id="L543">        generic: GenericT = .{ .<span class="tok-type">bool</span> = .{} },</span>
<span class="line" id="L544"></span>
<span class="line" id="L545">        <span class="tok-comment">/// Custom Help Function.</span></span>
<span class="line" id="L546">        <span class="tok-comment">/// Check (`Command.Config`) for details.</span></span>
<span class="line" id="L547">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> global_help_fn = config.global_help_fn;</span>
<span class="line" id="L548">        <span class="tok-comment">/// Custom Usage Function.</span></span>
<span class="line" id="L549">        <span class="tok-comment">/// Check (`Command.Config`) for details.</span></span>
<span class="line" id="L550">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> global_usage_fn = config.global_usage_fn;</span>
<span class="line" id="L551"></span>
<span class="line" id="L552">        <span class="tok-comment">/// Values Help Format.</span></span>
<span class="line" id="L553">        <span class="tok-comment">/// Check (`Command.Config`) for details.</span></span>
<span class="line" id="L554">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> vals_help_fmt = config.vals_help_fmt;</span>
<span class="line" id="L555">        <span class="tok-comment">/// Values Usage Format.</span></span>
<span class="line" id="L556">        <span class="tok-comment">/// Check (`Command.Config`) for details.</span></span>
<span class="line" id="L557">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> vals_usage_fmt = config.vals_usage_fmt;</span>
<span class="line" id="L558"></span>
<span class="line" id="L559">        <span class="tok-comment">/// Get the Parsed and Validated Value of the inner Typed Value.</span></span>
<span class="line" id="L560">        <span class="tok-comment">/// Comptime Only </span></span>
<span class="line" id="L561">        <span class="tok-comment">// TODO: See if this can be made Runtime</span>
</span>
<span class="line" id="L562">        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) !<span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) { </span>
<span class="line" id="L563">            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag))).ChildT, </span>
<span class="line" id="L564">        } {</span>
<span class="line" id="L565">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L566">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-kw">try</span> <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).get(),</span>
<span class="line" id="L567">            };</span>
<span class="line" id="L568">        }</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">        <span class="tok-comment">/// Get the Parsed and Validated value of the inner Typed Value as the specified type (`T`).</span></span>
<span class="line" id="L571">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAs</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) !T {</span>
<span class="line" id="L572">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L573">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| {</span>
<span class="line" id="L574">                    <span class="tok-kw">const</span> typed_val = <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag));</span>
<span class="line" id="L575">                    <span class="tok-kw">return</span> </span>
<span class="line" id="L576">                        <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(typed_val).ChildT == T) <span class="tok-kw">try</span> typed_val.get()</span>
<span class="line" id="L577">                        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (</span>
<span class="line" id="L578">                            <span class="tok-builtin">@typeInfo</span>(T) == .Enum <span class="tok-kw">or</span> (</span>
<span class="line" id="L579">                                <span class="tok-builtin">@typeInfo</span>(T) == .Optional <span class="tok-kw">and</span></span>
<span class="line" id="L580">                                <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(T).Optional.child) == .Enum</span>
<span class="line" id="L581">                            )</span>
<span class="line" id="L582">                        ) {</span>
<span class="line" id="L583">                            <span class="tok-kw">const</span> val = <span class="tok-kw">try</span> typed_val.get();</span>
<span class="line" id="L584">                            <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(val))) {</span>
<span class="line" id="L585">                                .Int =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(val),</span>
<span class="line" id="L586">                                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RequestedTypeMismatch,</span>
<span class="line" id="L587">                            }</span>
<span class="line" id="L588">                        }</span>
<span class="line" id="L589">                        <span class="tok-kw">else</span> <span class="tok-kw">error</span>.RequestedTypeMismatch;</span>
<span class="line" id="L590">                },</span>
<span class="line" id="L591">            };</span>
<span class="line" id="L592">        }</span>
<span class="line" id="L593"></span>
<span class="line" id="L594">        <span class="tok-comment">/// Set the inner Typed Value if the provided Argument (`arg`) can be Parsed and Validated.</span></span>
<span class="line" id="L595">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">set</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> { </span>
<span class="line" id="L596">            <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L597">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-kw">try</span> <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).set(arg),</span>
<span class="line" id="L598">            }</span>
<span class="line" id="L599">        }</span>
<span class="line" id="L600"></span>
<span class="line" id="L601">        <span class="tok-comment">/// Get the inner Typed Value's Allocator.</span></span>
<span class="line" id="L602">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocator</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) ?mem.Allocator {</span>
<span class="line" id="L603">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L604">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag))._alloc,</span>
<span class="line" id="L605">            };</span>
<span class="line" id="L606">        }</span>
<span class="line" id="L607"></span>
<span class="line" id="L608">        <span class="tok-comment">/// Get the inner Typed Value's Group.</span></span>
<span class="line" id="L609">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valGroup</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L610">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L611">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).val_group,</span>
<span class="line" id="L612">            };</span>
<span class="line" id="L613">        }</span>
<span class="line" id="L614"></span>
<span class="line" id="L615">        <span class="tok-comment">/// Get the inner Typed Value's Name.</span></span>
<span class="line" id="L616">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L617">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L618">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).name,</span>
<span class="line" id="L619">            };</span>
<span class="line" id="L620">        }</span>
<span class="line" id="L621">        <span class="tok-comment">/// Get the inner Typed Value's Child Type Name.</span></span>
<span class="line" id="L622">        <span class="tok-comment">/// This is where aliasing happens via `Value.Typed.alias_child_type` or `Value.Config.child_type_aliases`.</span></span>
<span class="line" id="L623">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">childType</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L624">            <span class="tok-builtin">@setEvalBranchQuota</span>(config.max_int_bit_width * <span class="tok-number">10</span>);</span>
<span class="line" id="L625">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L626">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| typeName: {</span>
<span class="line" id="L627">                    <span class="tok-kw">const</span> val = <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag));</span>
<span class="line" id="L628">                    <span class="tok-kw">break</span> :typeName </span>
<span class="line" id="L629">                        <span class="tok-kw">if</span> (val.alias_child_type) |alias| alias</span>
<span class="line" id="L630">                        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (config.child_type_aliases) |aliases| confAlias: {</span>
<span class="line" id="L631">                            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (aliases) |alias| {</span>
<span class="line" id="L632">                                <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(val).ChildT == alias.ChildT) <span class="tok-kw">break</span> :confAlias alias.alias;</span>
<span class="line" id="L633">                            }</span>
<span class="line" id="L634">                            <span class="tok-kw">break</span> :confAlias <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(val).ChildT);</span>
<span class="line" id="L635">                        }</span>
<span class="line" id="L636">                        <span class="tok-kw">else</span> <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(val).ChildT);</span>
<span class="line" id="L637">                }</span>
<span class="line" id="L638">            };</span>
<span class="line" id="L639">        }</span>
<span class="line" id="L640">        <span class="tok-comment">/// Get the inner Typed Value's Description.</span></span>
<span class="line" id="L641">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">description</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L642">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L643">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).description,</span>
<span class="line" id="L644">            };</span>
<span class="line" id="L645">        }</span>
<span class="line" id="L646">        <span class="tok-comment">/// Check if the inner Typed Value is Set.</span></span>
<span class="line" id="L647">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSet</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">bool</span> {</span>
<span class="line" id="L648">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L649">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).is_set,</span>
<span class="line" id="L650">            };</span>
<span class="line" id="L651">        }</span>
<span class="line" id="L652">        <span class="tok-comment">/// Check if the inner Typed Value has a default value.</span></span>
<span class="line" id="L653">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasDefault</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">bool</span> {</span>
<span class="line" id="L654">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L655">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).default_val != <span class="tok-null">null</span>,</span>
<span class="line" id="L656">            };</span>
<span class="line" id="L657">        }</span>
<span class="line" id="L658">        <span class="tok-comment">/// Get the inner Typed Value's Argument Index.</span></span>
<span class="line" id="L659">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argIdx</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u7</span> {</span>
<span class="line" id="L660">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L661">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag))._arg_idx,</span>
<span class="line" id="L662">            };</span>
<span class="line" id="L663">        }</span>
<span class="line" id="L664">        <span class="tok-comment">/// Get the inner Typed Value's Max Arguments.</span></span>
<span class="line" id="L665">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">maxArgs</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">u7</span> {</span>
<span class="line" id="L666">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L667">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).max_args,</span>
<span class="line" id="L668">            };</span>
<span class="line" id="L669">        }</span>
<span class="line" id="L670">        <span class="tok-comment">/// Check if the inner Typed Value's has a custom `parse_fn`.</span></span>
<span class="line" id="L671">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasCustomParseFn</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">bool</span> {</span>
<span class="line" id="L672">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L673">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| hasFn: {</span>
<span class="line" id="L674">                    <span class="tok-kw">const</span> val = <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag));</span>
<span class="line" id="L675">                    <span class="tok-kw">break</span> :hasFn val.parse_fn != <span class="tok-null">null</span> <span class="tok-kw">or</span> <span class="tok-builtin">@TypeOf</span>(val).child_type_parse_fn != <span class="tok-null">null</span>;</span>
<span class="line" id="L676">                }</span>
<span class="line" id="L677">            };</span>
<span class="line" id="L678">        }</span>
<span class="line" id="L679">        <span class="tok-comment">/// Check if the inner Typed Value's has a custom `valid_fn`.</span></span>
<span class="line" id="L680">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasCustomValidFn</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">bool</span> {</span>
<span class="line" id="L681">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L682">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).valid_fn != <span class="tok-null">null</span>,</span>
<span class="line" id="L683">            };</span>
<span class="line" id="L684">        }</span>
<span class="line" id="L685">        <span class="tok-comment">/// Check if the inner Typed Value's has a custom `parse_fn` or `valid_fn`.</span></span>
<span class="line" id="L686">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasCustomFn</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) <span class="tok-type">bool</span> {</span>
<span class="line" id="L687">            <span class="tok-kw">return</span> self.hasCustomParseFn() <span class="tok-kw">or</span> self.hasCustomValidFn();</span>
<span class="line" id="L688">        }</span>
<span class="line" id="L689"></span>
<span class="line" id="L690">        <span class="tok-comment">/// Create a Custom Value with a specific Type (`T`).</span></span>
<span class="line" id="L691">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ofType</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> typed_val: Typed(T, config)) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L692">            <span class="tok-kw">const</span> active_tag = </span>
<span class="line" id="L693">                <span class="tok-kw">if</span> (T == []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-str">&quot;string&quot;</span> </span>
<span class="line" id="L694">                <span class="tok-comment">//else if (@typeInfo(T) == .Enum) @typeName(@typeInfo(T).Enum.tag_type)</span>
</span>
<span class="line" id="L695">                <span class="tok-kw">else</span> <span class="tok-builtin">@typeName</span>(T);</span>
<span class="line" id="L696">            <span class="tok-kw">return</span> <span class="tok-builtin">@This</span>(){ .generic = <span class="tok-builtin">@unionInit</span>(GenericT, active_tag, typed_val) };</span>
<span class="line" id="L697">        }</span>
<span class="line" id="L698"></span>
<span class="line" id="L699">        <span class="tok-comment">/// Config for creating Values from Componenet Types (Function Parameters, Struct Fields, and Union Fields) using `from()`.</span></span>
<span class="line" id="L700">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FromConfig = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L701">            <span class="tok-comment">/// Ignore Incompatible types or error during compile time.</span></span>
<span class="line" id="L702">            ignore_incompatible: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L703">            <span class="tok-comment">/// Name for the Value.</span></span>
<span class="line" id="L704">            <span class="tok-comment">/// If this is left blank, an attempt will be made to create a name based on the Component Type.</span></span>
<span class="line" id="L705">            val_name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L706">            <span class="tok-comment">/// Description for the Value.</span></span>
<span class="line" id="L707">            val_description: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L708">        };</span>
<span class="line" id="L709"></span>
<span class="line" id="L710">        <span class="tok-comment">/// Create a Generic Value from a Valid Componenent Param, StructField, or UnionField (`from_comp`) using the provided FromConfig (`from_config`).</span></span>
<span class="line" id="L711">        <span class="tok-comment">/// This is intended for use with the corresponding `from()` methods in Command and Option, which ultimately create a Command from a given Struct.</span></span>
<span class="line" id="L712">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">from</span>(<span class="tok-kw">comptime</span> from_comp: <span class="tok-kw">anytype</span>, from_config: FromConfig) ?<span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L713">            <span class="tok-kw">const</span> comp_name = </span>
<span class="line" id="L714">                <span class="tok-kw">if</span> (from_config.val_name) |val_name| val_name    </span>
<span class="line" id="L715">                <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(from_comp)) {</span>
<span class="line" id="L716">                    std.builtin.Type.StructField, std.builtin.Type.UnionField =&gt; from_comp.name,</span>
<span class="line" id="L717">                    std.builtin.Type.Fn.Param =&gt; <span class="tok-str">&quot;&quot;</span>,</span>
<span class="line" id="L718">                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The provided component must be a Function Parameter, Struct Field, or Union Field.&quot;</span>), </span>
<span class="line" id="L719">                };</span>
<span class="line" id="L720"></span>
<span class="line" id="L721">            <span class="tok-kw">const</span> FromT = <span class="tok-kw">switch</span>(<span class="tok-builtin">@TypeOf</span>(from_comp)) {</span>
<span class="line" id="L722">               std.builtin.Type.StructField, std.builtin.Type.UnionField =&gt; from_comp.<span class="tok-type">type</span>,</span>
<span class="line" id="L723">               std.builtin.Type.Fn.Param =&gt; from_comp.<span class="tok-type">type</span>.?,</span>
<span class="line" id="L724">               <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L725">            };</span>
<span class="line" id="L726">            <span class="tok-kw">const</span> comp_info = <span class="tok-builtin">@typeInfo</span>(FromT);</span>
<span class="line" id="L727">            <span class="tok-kw">if</span> (comp_info == .Pointer <span class="tok-kw">and</span> comp_info.Pointer.child != <span class="tok-type">u8</span>) {</span>
<span class="line" id="L728">                <span class="tok-kw">if</span> (!from_config.ignore_incompatible) <span class="tok-builtin">@compileError</span>(</span>
<span class="line" id="L729">                    <span class="tok-str">&quot;The component '&quot;</span> ++ </span>
<span class="line" id="L730">                    <span class="tok-kw">if</span> (comp_name.len &gt; <span class="tok-number">0</span>) comp_name <span class="tok-kw">else</span> <span class="tok-str">&quot;' function parameter of type '&quot;</span> ++ </span>
<span class="line" id="L731">                    <span class="tok-builtin">@typeName</span>(FromT) ++ <span class="tok-str">&quot;' is incompatible. Pointers must be of type '[]const u8'.&quot;</span>)</span>
<span class="line" id="L732">                <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L733">            }</span>
<span class="line" id="L734">            <span class="tok-kw">const</span> CompT = <span class="tok-kw">switch</span> (comp_info) {</span>
<span class="line" id="L735">                .Optional =&gt; |optl| OptT: {</span>
<span class="line" id="L736">                    <span class="tok-kw">break</span> :OptT <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(optl.child)) {</span>
<span class="line" id="L737">                        .Enum =&gt; |enum_info| enum_info.tag_type,</span>
<span class="line" id="L738">                        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; optl.child,</span>
<span class="line" id="L739">                    };</span>
<span class="line" id="L740">                },</span>
<span class="line" id="L741">                .Array =&gt; aryType: {</span>
<span class="line" id="L742">                    <span class="tok-kw">const</span> ary_info = <span class="tok-builtin">@typeInfo</span>(comp_info.Array.child);</span>
<span class="line" id="L743">                    <span class="tok-kw">if</span> (ary_info == .Optional) <span class="tok-kw">break</span> :aryType ary_info.Optional.child</span>
<span class="line" id="L744">                    <span class="tok-kw">else</span> <span class="tok-kw">break</span> :aryType comp_info.Array.child;</span>
<span class="line" id="L745">                },</span>
<span class="line" id="L746">                .Enum =&gt; |enum_info| enum_info.tag_type,</span>
<span class="line" id="L747">                <span class="tok-comment">// TODO: Check if Pointer is a String.</span>
</span>
<span class="line" id="L748">                .Bool, .Int, .Float, .Pointer =&gt; FromT,</span>
<span class="line" id="L749">                <span class="tok-kw">else</span> =&gt; { </span>
<span class="line" id="L750">                    <span class="tok-kw">if</span> (!from_config.ignore_incompatible) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The comp '&quot;</span> ++ comp_name ++ <span class="tok-str">&quot;' of type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(FromT) ++ <span class="tok-str">&quot;' is incompatible.&quot;</span>)</span>
<span class="line" id="L751">                    <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L752">                },</span>
<span class="line" id="L753">            };</span>
<span class="line" id="L754">            <span class="tok-comment">//const out_info = @typeInfo(CompT);</span>
</span>
<span class="line" id="L755">            <span class="tok-kw">return</span> ofType(CompT, .{</span>
<span class="line" id="L756">                .name = comp_name,</span>
<span class="line" id="L757">                .description = from_config.val_description <span class="tok-kw">orelse</span> <span class="tok-str">&quot;The '&quot;</span> ++ comp_name ++ <span class="tok-str">&quot;' Value of type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(FromT) ++ <span class="tok-str">&quot;'.&quot;</span>,</span>
<span class="line" id="L758">                .max_args = </span>
<span class="line" id="L759">                    <span class="tok-kw">if</span> (comp_info == .Array) comp_info.Array.len</span>
<span class="line" id="L760">                    <span class="tok-kw">else</span> <span class="tok-number">1</span>,</span>
<span class="line" id="L761">                .set_behavior =</span>
<span class="line" id="L762">                    <span class="tok-kw">if</span> (comp_info == .Array) .Multi</span>
<span class="line" id="L763">                    <span class="tok-kw">else</span> .Last,</span>
<span class="line" id="L764">                <span class="tok-comment">// TODO: Handle default Array Elements.</span>
</span>
<span class="line" id="L765">                .default_val = defVal: { </span>
<span class="line" id="L766">                    <span class="tok-kw">if</span> (</span>
<span class="line" id="L767">                        utils.indexOfEql([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, meta.fieldNames(<span class="tok-builtin">@TypeOf</span>(from_comp))[<span class="tok-number">0</span>..], <span class="tok-str">&quot;default_value&quot;</span>) != <span class="tok-null">null</span> <span class="tok-kw">and</span> </span>
<span class="line" id="L768">                        from_comp.default_value != <span class="tok-null">null</span></span>
<span class="line" id="L769">                    ) {</span>
<span class="line" id="L770">                        <span class="tok-kw">switch</span> (comp_info) {</span>
<span class="line" id="L771">                            .Array =&gt; <span class="tok-kw">break</span> :defVal <span class="tok-null">null</span>,</span>
<span class="line" id="L772">                            .Optional =&gt; |optl| {</span>
<span class="line" id="L773">                                <span class="tok-kw">break</span> :defVal <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(optl.child)) {</span>
<span class="line" id="L774">                                    .Enum =&gt; <span class="tok-kw">break</span> :defVal <span class="tok-null">null</span>,</span>
<span class="line" id="L775">                                    <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :defVal <span class="tok-builtin">@as</span>(*FromT, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@constCast</span>(from_comp.default_value)))).*,</span>
<span class="line" id="L776">                                };</span>
<span class="line" id="L777">                            },</span>
<span class="line" id="L778">                            .Enum =&gt; <span class="tok-kw">break</span> :defVal <span class="tok-number">0</span>, </span>
<span class="line" id="L779">                            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :defVal <span class="tok-builtin">@as</span>(*FromT, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@constCast</span>(from_comp.default_value.?)))).*</span>
<span class="line" id="L780">                        }</span>
<span class="line" id="L781">                    }</span>
<span class="line" id="L782">                    <span class="tok-kw">else</span> <span class="tok-kw">break</span> :defVal <span class="tok-null">null</span>;</span>
<span class="line" id="L783">                },</span>
<span class="line" id="L784">                .parse_fn = pFn: {</span>
<span class="line" id="L785">                    <span class="tok-kw">switch</span> (comp_info) {</span>
<span class="line" id="L786">                        .Optional =&gt; |optl| {</span>
<span class="line" id="L787">                            <span class="tok-kw">break</span> :pFn <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(optl.child)) {</span>
<span class="line" id="L788">                                .Enum =&gt; ParsingFns.Builder.asEnumType(optl.child),</span>
<span class="line" id="L789">                                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,</span>
<span class="line" id="L790">                            };</span>
<span class="line" id="L791">                        },</span>
<span class="line" id="L792">                        .Enum =&gt; <span class="tok-kw">break</span> :pFn ParsingFns.Builder.asEnumType(FromT),</span>
<span class="line" id="L793">                        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :pFn <span class="tok-null">null</span>,</span>
<span class="line" id="L794">                    }</span>
<span class="line" id="L795">                },</span>
<span class="line" id="L796">            });</span>
<span class="line" id="L797">        }</span>
<span class="line" id="L798"></span>
<span class="line" id="L799">        <span class="tok-comment">/// Format function for Values</span></span>
<span class="line" id="L800">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(self: <span class="tok-builtin">@This</span>(), _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, _: fmt.FormatOptions, writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L801">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}&quot;</span>, .{ <span class="tok-builtin">@tagName</span>(meta.activeTag(self.generic)) });</span>
<span class="line" id="L802">            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}:  Type: {s}, Set: {any}&quot;</span>, .{</span>
<span class="line" id="L803">                self.name(),</span>
<span class="line" id="L804">                self.childType(),</span>
<span class="line" id="L805">                self.isSet(),</span>
<span class="line" id="L806">            });</span>
<span class="line" id="L807">        }</span>
<span class="line" id="L808"></span>
<span class="line" id="L809">        <span class="tok-comment">/// Creates the Help message for this Value and Writes it to the provided Writer (`writer`).</span></span>
<span class="line" id="L810">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">help</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L811">            <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L812">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| {</span>
<span class="line" id="L813">                    <span class="tok-kw">const</span> val = <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag));</span>
<span class="line" id="L814">                    <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(val).child_type_help_fn)|helpFn| <span class="tok-kw">return</span> helpFn(self, writer, self.allocator() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNotInitialized);</span>
<span class="line" id="L815">                }</span>
<span class="line" id="L816">            }</span>
<span class="line" id="L817">            <span class="tok-kw">if</span> (global_help_fn) |helpFn| <span class="tok-kw">return</span> helpFn(self, writer, self.allocator() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNotInitialized);</span>
<span class="line" id="L818">            <span class="tok-kw">try</span> writer.print(vals_help_fmt, .{ self.name(), self.childType(), self.description() });</span>
<span class="line" id="L819">        }</span>
<span class="line" id="L820">        <span class="tok-comment">/// Creates the Usage message for this Value and Writes it to the provided Writer (`writer`).</span></span>
<span class="line" id="L821">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">usage</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), writer: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L822">            <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L823">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| {</span>
<span class="line" id="L824">                    <span class="tok-kw">const</span> val = <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag));</span>
<span class="line" id="L825">                    <span class="tok-kw">if</span> (<span class="tok-builtin">@TypeOf</span>(val).child_type_usage_fn)|usageFn| <span class="tok-kw">return</span> usageFn(self, writer, self.allocator() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNotInitialized);</span>
<span class="line" id="L826">                }</span>
<span class="line" id="L827">            }</span>
<span class="line" id="L828">            <span class="tok-kw">if</span> (global_usage_fn) |usageFn| <span class="tok-kw">return</span> usageFn(self, writer, self.allocator <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ValueNotInitialized);</span>
<span class="line" id="L829">            <span class="tok-kw">try</span> writer.print(vals_usage_fmt, .{ self.name(), self.childType() });</span>
<span class="line" id="L830">        }</span>
<span class="line" id="L831"></span>
<span class="line" id="L832">        <span class="tok-comment">/// Initialize this Value with the provided Allocator (`alloc`).</span></span>
<span class="line" id="L833">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(self: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>(), alloc: mem.Allocator) <span class="tok-builtin">@This</span>() {</span>
<span class="line" id="L834">            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (meta.activeTag(self.*.generic)) {</span>
<span class="line" id="L835">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@This</span>(){ .generic = <span class="tok-builtin">@unionInit</span>(GenericT, <span class="tok-builtin">@tagName</span>(tag), <span class="tok-builtin">@field</span>(self.*.generic, <span class="tok-builtin">@tagName</span>(tag)).init(alloc)) },</span>
<span class="line" id="L836">            };</span>
<span class="line" id="L837">        }</span>
<span class="line" id="L838">    };</span>
<span class="line" id="L839">}</span>
<span class="line" id="L840"></span>
<span class="line" id="L841"><span class="tok-comment">/// Parsing Functions for various common requirements to be used with `parse_fn` in place of normal `parse()`.</span></span>
<span class="line" id="L842"><span class="tok-comment">/// Note, `parse_fn` is in no way limited to these functions.</span></span>
<span class="line" id="L843"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParsingFns = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L844">    <span class="tok-comment">/// Builder Functions for common Parsing Functions.</span></span>
<span class="line" id="L845">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Builder = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L846">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BoolNoMatch = <span class="tok-kw">enum</span>{</span>
<span class="line" id="L847">            True,</span>
<span class="line" id="L848">            False,</span>
<span class="line" id="L849">            Error,</span>
<span class="line" id="L850">        };</span>
<span class="line" id="L851">        <span class="tok-comment">/// Check for Alternate True Words (`true_words`) and False Words (`false_words`) when parsing the provided Argument (`arg`) to a Boolean.</span></span>
<span class="line" id="L852">        <span class="tok-comment">/// In the event of no match, This function will return based on (`no_match`).</span></span>
<span class="line" id="L853">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">altBool</span>(</span>
<span class="line" id="L854">            <span class="tok-kw">comptime</span> true_words: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L855">            <span class="tok-kw">comptime</span> false_words: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L856">            <span class="tok-kw">comptime</span> no_match: BoolNoMatch</span>
<span class="line" id="L857">        ) <span class="tok-kw">fn</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mem.Allocator) <span class="tok-type">anyerror</span>!<span class="tok-type">bool</span> {</span>
<span class="line" id="L858">            <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L859">                <span class="tok-kw">fn</span> <span class="tok-fn">boolCheck</span>(arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, alloc: mem.Allocator) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L860">                    _ = alloc;</span>
<span class="line" id="L861">                    <span class="tok-kw">for</span> (true_words[<span class="tok-number">0</span>..]) |word| { <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, word, arg)) <span class="tok-kw">return</span> <span class="tok-null">true</span>; } </span>
<span class="line" id="L862">                    <span class="tok-kw">else</span> <span class="tok-kw">for</span> (false_words[<span class="tok-number">0</span>..]) |word| { <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, word, arg)) <span class="tok-kw">return</span> <span class="tok-null">false</span>; } </span>
<span class="line" id="L863">                    <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (no_match) {</span>
<span class="line" id="L864">                        .True =&gt; <span class="tok-null">true</span>,</span>
<span class="line" id="L865">                        .False =&gt; <span class="tok-null">false</span>,</span>
<span class="line" id="L866">                        .Error =&gt; <span class="tok-kw">error</span>.UnrecognizedBooleanValue,</span>
<span class="line" id="L867">                    };</span>
<span class="line" id="L868">                }</span>
<span class="line" id="L869">            }.boolCheck;</span>
<span class="line" id="L870">        }</span>
<span class="line" id="L871"></span>
<span class="line" id="L872">        <span class="tok-comment">/// Parse the given Integer (`arg`) as Base (`base`). Base options:</span></span>
<span class="line" id="L873">        <span class="tok-comment">/// - 0: Uses the 2 character prefix to determine the base. Default is Base 10. (This is also the default parsing option for Integers.)</span></span>
<span class="line" id="L874">        <span class="tok-comment">/// - 2: Base 2 / Binary</span></span>
<span class="line" id="L875">        <span class="tok-comment">/// - 8: Base 8 / Octal</span></span>
<span class="line" id="L876">        <span class="tok-comment">/// - 10: Base 10 / Decimal</span></span>
<span class="line" id="L877">        <span class="tok-comment">/// - 16: Base 16 / Hexadecimal</span></span>
<span class="line" id="L878">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asBase</span>(<span class="tok-kw">comptime</span> NumT: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> base: <span class="tok-type">u8</span>) <span class="tok-kw">fn</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mem.Allocator) <span class="tok-type">anyerror</span>!NumT {</span>
<span class="line" id="L879">            <span class="tok-kw">return</span> <span class="tok-kw">struct</span> { </span>
<span class="line" id="L880">                <span class="tok-kw">fn</span> <span class="tok-fn">toBase</span>(arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, alloc: mem.Allocator) !NumT { </span>
<span class="line" id="L881">                    _ = alloc;</span>
<span class="line" id="L882">                    <span class="tok-kw">return</span> fmt.parseInt(NumT, arg, base); </span>
<span class="line" id="L883">                } </span>
<span class="line" id="L884">            }.toBase;</span>
<span class="line" id="L885">        }</span>
<span class="line" id="L886"></span>
<span class="line" id="L887">        <span class="tok-comment">/// Parse the given argument token (`arg`) to an Enum Tag of the provided `EnumT`.</span></span>
<span class="line" id="L888">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asEnumType</span>(<span class="tok-kw">comptime</span> EnumT: <span class="tok-type">type</span>) enumFnType: {</span>
<span class="line" id="L889">            <span class="tok-kw">const</span> enum_info = <span class="tok-builtin">@typeInfo</span>(EnumT);</span>
<span class="line" id="L890">            <span class="tok-kw">if</span> (enum_info != .Enum) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The type of `EnumT` must be Enum!&quot;</span>);</span>
<span class="line" id="L891">            <span class="tok-kw">break</span> :enumFnType <span class="tok-kw">fn</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mem.Allocator) <span class="tok-type">anyerror</span>!enum_info.Enum.tag_type;</span>
<span class="line" id="L892">        } {</span>
<span class="line" id="L893">            <span class="tok-kw">const</span> EnumTagT: <span class="tok-type">type</span> = <span class="tok-builtin">@typeInfo</span>(EnumT).Enum.tag_type;</span>
<span class="line" id="L894">            <span class="tok-kw">return</span> <span class="tok-kw">struct</span> { </span>
<span class="line" id="L895">                <span class="tok-kw">fn</span> <span class="tok-fn">enumInt</span>(arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, alloc: mem.Allocator) !EnumTagT {</span>
<span class="line" id="L896">                    _ = alloc;</span>
<span class="line" id="L897">                    <span class="tok-kw">const</span> enum_tag = meta.stringToEnum(EnumT, mem.trim(<span class="tok-type">u8</span>, arg, &amp;.{ <span class="tok-number">0</span>, <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span> })) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnumTagDoesNotExist;</span>
<span class="line" id="L898">                    <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(enum_tag);</span>
<span class="line" id="L899">                }</span>
<span class="line" id="L900">            }.enumInt;</span>
<span class="line" id="L901">        }</span>
<span class="line" id="L902"></span>
<span class="line" id="L903">    };</span>
<span class="line" id="L904"></span>
<span class="line" id="L905">    <span class="tok-comment">/// Trim all Whitespace from the beginning and end of the provided argument token (`arg`).</span></span>
<span class="line" id="L906">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimWhitespace</span>(arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, alloc: mem.Allocator) <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L907">        _ = alloc;</span>
<span class="line" id="L908">        <span class="tok-kw">return</span> mem.trim(<span class="tok-type">u8</span>, arg, ascii.whitespace[<span class="tok-number">0</span>..]);</span>
<span class="line" id="L909">    }</span>
<span class="line" id="L910"></span>
<span class="line" id="L911">    <span class="tok-comment">/// Return the provided argument token (`arg`) in all uppercase.</span></span>
<span class="line" id="L912">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toUpper</span>(arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, alloc: mem.Allocator) <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L913">        <span class="tok-kw">const</span> out_buf = <span class="tok-kw">try</span> alloc.alloc(<span class="tok-type">u8</span>, arg.len);</span>
<span class="line" id="L914">        <span class="tok-kw">return</span> ascii.upperString(out_buf, arg);</span>
<span class="line" id="L915">    }</span>
<span class="line" id="L916"></span>
<span class="line" id="L917">    <span class="tok-comment">/// Return the provided argument token (`arg`) in all lowercase.</span></span>
<span class="line" id="L918">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toLower</span>(arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, alloc: mem.Allocator) <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L919">        <span class="tok-kw">const</span> out_buf = <span class="tok-kw">try</span> alloc.alloc(<span class="tok-type">u8</span>, arg.len);</span>
<span class="line" id="L920">        <span class="tok-kw">return</span> ascii.lowerString(out_buf, arg);</span>
<span class="line" id="L921">    }</span>
<span class="line" id="L922">};</span>
<span class="line" id="L923"></span>
<span class="line" id="L924"><span class="tok-comment">/// Validation Functions for various common requirements to be used with `valid_fn`.</span></span>
<span class="line" id="L925"><span class="tok-comment">/// Note, `valid_fn` is in no way limited to these functions.</span></span>
<span class="line" id="L926"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ValidationFns = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L927">    <span class="tok-comment">/// Builder Functions for common Validation Functions.</span></span>
<span class="line" id="L928">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Builder = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L929">        <span class="tok-comment">/// Check if the provided `NumT` (`num`) is within an inclusive or exclusive range.</span></span>
<span class="line" id="L930">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inRange</span>(<span class="tok-kw">comptime</span> NumT: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> start: NumT, <span class="tok-kw">comptime</span> end: NumT, <span class="tok-kw">comptime</span> inclusive: <span class="tok-type">bool</span>) <span class="tok-kw">fn</span>(NumT, mem.Allocator) <span class="tok-type">bool</span> {</span>
<span class="line" id="L931">            <span class="tok-kw">const</span> num_info = <span class="tok-builtin">@typeInfo</span>(NumT);</span>
<span class="line" id="L932">            <span class="tok-kw">switch</span> (num_info) {</span>
<span class="line" id="L933">                .Int, .Float =&gt; {},</span>
<span class="line" id="L934">                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The provided type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(NumT) ++ <span class="tok-str">&quot;' is not a numeric type. It must be an Integer or a Float.&quot;</span>),</span>
<span class="line" id="L935">            }</span>
<span class="line" id="L936"></span>
<span class="line" id="L937">            <span class="tok-kw">return</span> </span>
<span class="line" id="L938">                <span class="tok-kw">if</span> (inclusive) <span class="tok-kw">struct</span> { <span class="tok-kw">fn</span> <span class="tok-fn">inRng</span>(num: NumT, alloc: mem.Allocator) <span class="tok-type">bool</span> { _ = alloc; <span class="tok-kw">return</span> num &gt;= start <span class="tok-kw">and</span> num &lt;= end; } }.inRng</span>
<span class="line" id="L939">                <span class="tok-kw">else</span> <span class="tok-kw">struct</span> { <span class="tok-kw">fn</span> <span class="tok-fn">inRng</span>(num: NumT, alloc: mem.Allocator) <span class="tok-type">bool</span> { _ = alloc; <span class="tok-kw">return</span> num &gt; start <span class="tok-kw">and</span> num &lt; end; } }.inRng;</span>
<span class="line" id="L940">        }</span>
<span class="line" id="L941">    };</span>
<span class="line" id="L942"></span>
<span class="line" id="L943">    <span class="tok-comment">/// Check if the provided argument token (`filepath`) is a valid filepath.</span></span>
<span class="line" id="L944">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validFilepath</span>(filepath: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, alloc: mem.Allocator) <span class="tok-type">bool</span> {</span>
<span class="line" id="L945">        _ = alloc;</span>
<span class="line" id="L946">        <span class="tok-kw">const</span> test_file = fs.cwd().openFile(filepath, .{}) <span class="tok-kw">catch</span> {</span>
<span class="line" id="L947">            log.err(<span class="tok-str">&quot;The file '{s}' could not be found.&quot;</span>, .{ filepath });</span>
<span class="line" id="L948">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L949">        };</span>
<span class="line" id="L950">        test_file.close();</span>
<span class="line" id="L951">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L952">    } </span>
<span class="line" id="L953">    <span class="tok-comment">/// Check if the provided argument token (`num_str`) is a valid Ordinal Number.</span></span>
<span class="line" id="L954">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ordinalNum</span>(num_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, alloc: mem.Allocator) <span class="tok-type">bool</span> {</span>
<span class="line" id="L955">        _ = alloc;</span>
<span class="line" id="L956">        <span class="tok-kw">const</span> ordinals = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L957">            first,</span>
<span class="line" id="L958">            second,</span>
<span class="line" id="L959">            third,</span>
<span class="line" id="L960">            fourth,</span>
<span class="line" id="L961">            fifth,</span>
<span class="line" id="L962">            sixth,</span>
<span class="line" id="L963">            seventh,</span>
<span class="line" id="L964">            eigth,</span>
<span class="line" id="L965">            ninth,</span>
<span class="line" id="L966">            tenth,</span>
<span class="line" id="L967">        };</span>
<span class="line" id="L968">        <span class="tok-kw">var</span> lower_buf: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L969">        <span class="tok-kw">const</span> lower_slice = toLower(lower_buf[<span class="tok-number">0</span>..], num_str);</span>
<span class="line" id="L970">        <span class="tok-kw">return</span> meta.stringToEnum(ordinals, lower_slice) != <span class="tok-null">null</span>;</span>
<span class="line" id="L971">    }</span>
<span class="line" id="L972">};</span>
<span class="line" id="L973"></span>
<span class="line" id="L974"></span>
</code></pre></body>
</html>