//! Generate Tab Completion scripts for various shells based on Cova Commands.

// Standard
const std = @import("std");
const fmt = std.fmt;
const fs = std.fs;
const log = std.log;
const mem = std.mem;

// Cova
const utils = @import("../utils.zig");

/// Config for creating tab completion scripts with `createTabCompletion()`.
pub const TabCompletionConfig = struct {
    /// Script Local Filepath
    /// This is the local path the file will be placed in. The file name will be "`name`-completion.`shell_kind`".
    local_filepath: []const u8 = "meta/tab_completions",

    /// Script Header
    /// This is useful for setting the shebang of a shell and, optionally, header comments.
    /// If this is left null, a default shebang or value for the given Shell Kind will be used.
    script_header: ?[]const u8 = null,
    /// Name of the program.
    /// Note, if this is left null, the provided CommandT's name will be used.
    name: ?[]const u8 = null,

    /// Include Commands for Tab Completion.
    include_cmds: bool = true,
    /// Include Options for Tab Completion.
    include_opts: bool = false,
    /// Include Usage/Help for Tab Completion.
    include_usage_help: bool = true,
    /// Allow Cova Library message.
    /// By default the `createTabCompletion()` function will write a short message stating the script was generated by the Cova Library.
    add_cova_lib_msg: bool = true,
    /// Add Installation Instructions for the generated Tab Completion script.
    add_install_instructions: bool = true,

    /// Available Kinds of Shells for Tab Completion scripts.
    pub const ShellKind = enum {
        bash,
        zsh,
        ps1,
    };
};
/// Create a Tab Completion script for the provided CommandT (`cmd`) configured by the given TabCompletionConfig (`tc_config`).
pub fn createTabCompletion(
    comptime CommandT: type,
    comptime cmd: CommandT,
    comptime tc_config: TabCompletionConfig,
    comptime shell_kind: TabCompletionConfig.ShellKind,
) !void {
    //log.info("Generating '{s}' Tab Completion for '{s}'...", .{ @tagName(shell_kind), cmd.name });
    const tc_name = tc_config.name orelse cmd.name;
    const script_header = tc_config.script_header orelse switch (shell_kind) {
        .bash => "#! /usr/bin/env bash",
        .zsh => "#compdef " ++ cmd.name,
        .ps1 => "# Requires PowerShell v5.1+",
    };

    const filename = (if (shell_kind == .zsh) "_" else "") ++ tc_name ++ "-completion." ++ @tagName(shell_kind);
    const filepath = genFilepath: {
        comptime var path = if (tc_config.local_filepath.len >= 0) tc_config.local_filepath else ".";
        comptime {
            if (mem.indexOfScalar(u8, &.{ '/', '\\' }, path[path.len - 1]) == null) path = path ++ "/";
        }
        try fs.cwd().makePath(path);
        const path_out = path;
        break :genFilepath path_out ++ filename;
    };
    var tab_completion = try fs.cwd().createFile(filepath, .{});
    var tc_writer = tab_completion.writer();
    defer tab_completion.close();

    // Tab Completion Script Header Write
    try tc_writer.print(
        \\{s}
        \\
        \\{s}
        \\
        \\
        \\
    , .{
        script_header,
        if (tc_config.add_cova_lib_msg)
            \\# This Tab Completion script was generated by the Cova Library.
            \\# Details at https://github.com/00JCIV00/cova
        else
            "",
    });
    const tc_ctx = TabCompletionContext{
        .name = tc_name,
        .include_cmds = tc_config.include_cmds,
        .include_opts = tc_config.include_opts,
        .include_usage_help = tc_config.include_usage_help,
    };

    switch (shell_kind) {
        .bash => {
            if (tc_config.add_install_instructions) {
                try tc_writer.print(
                    \\# Bash Completion Installation Instructions for {s}
                    \\# 1. Place this script in a directory like /etc/bash_completion.d/ (Linux)
                    \\#    or /usr/local/etc/bash_completion.d/ (Mac, if using Homebrew and bash-completion)
                    \\#
                    \\# 2. Ensure the script has executable permissions:
                    \\#    chmod +x {s}
                    \\#
                    \\# 3. Source this script from your .bashrc or .bash_profile by adding:
                    \\#    . /path/to/{s}
                    \\#
                    \\# 4. Restart your terminal session or source your profile again:
                    \\#    source ~/.bashrc  # or ~/.bash_profile
                    \\
                    \\
                    \\
                , .{
                    tc_name,
                    filename,
                    filename,
                });
            }
            try cmdTabCompletionBash(CommandT, cmd, tc_writer, tc_ctx);
        },
        .zsh => {
            if (tc_config.add_install_instructions) {
                try tc_writer.print(
                    \\# Zsh Completion Installation Instructions for {s}
                    \\# 1. Place this script in a directory specified in your $fpath, or a new one such as
                    \\#    ~/.zsh/completion/
                    \\#
                    \\# 2. Ensure the script has executable permissions:
                    \\#    chmod +x {s}
                    \\#
                    \\# 3. Add the script's directory to your $fpath in your .zshrc if not already included:
                    \\#    fpath=(~/.zsh/completion $fpath)
                    \\#
                    \\# 4. Enable and initialize completion in your .zshrc if you haven't already (oh-my-zsh does this automatically):
                    \\#    autoload -Uz compinit && compinit
                    \\#
                    \\# 5. Restart your terminal session or source your .zshrc again:
                    \\#    source ~/.zshrc
                    \\
                    \\
                    \\
                , .{
                    tc_name,
                    filename,
                });
            }
            try cmdTabCompletionZsh(CommandT, cmd, tc_writer, tc_ctx);
        },
        .ps1 => {
            if (tc_config.add_install_instructions) {
                try tc_writer.print(
                    \\# PowerShell Completion Installation Instructions for {s}
                    \\# 1. Load the completion script into your current PowerShell session:
                    \\#    . .\{s}
                    \\#
                    \\# 2. Ensure your Execution Policy allows the script to be run. Example:
                    \\#    Set-ExecutionPolicy RemoteSigned
                    \\#
                    \\# 3. To ensure this completion script is loaded automatically in future sessions,
                    \\#    add the above sourcing command to your PowerShell profile:
                    \\#    Notepad $PROFILE
                    \\#    Add the line: . C:\path\to\{s}
                    \\#
                    \\# 4. Restart your PowerShell session or source your profile again:
                    \\#    . $PROFILE
                    \\
                    \\
                    \\
                , .{
                    tc_name,
                    filename,
                    filename,
                });
            }
            try cmdTabCompletionPowerShell(CommandT, cmd, tc_writer, tc_ctx);
        },
    }
    log.info("Generated '{s}' Tab Completion script for '{s}' into '{s}'.", .{ @tagName(shell_kind), cmd.name, filepath });
}

/// Context used to track info through recursive calls of `cmdTabCompletion...()` functions.
const TabCompletionContext = struct {
    /// Parent Command Name
    parent_name: []const u8 = "",
    /// Command Name
    name: []const u8 = "",
    /// Argument Index
    idx: u8 = 1,
    /// Include Commands for Tab Completion.
    include_cmds: bool = true,
    /// Include Options for Tab Completion.
    include_opts: bool = false,
    /// Include Usage/Help for Tab Completion.
    include_usage_help: bool = true,
};

/// Writes a Bash Tab Completion script snippet for the provided CommandT (`cmd`) to the given Writer (`tc_writer`).
/// This function passes the provided TabCompletionContext (`tc_ctx`) to track info through recursive calls.
fn cmdTabCompletionBash(
    comptime CommandT: type,
    comptime cmd: CommandT,
    tc_writer: anytype,
    comptime tc_ctx: TabCompletionContext,
) !void {
    // Get Sub Commands and Options
    const long_pf = CommandT.OptionT.long_prefix orelse "";
    const args_list: []const u8 = comptime genArgList: {
        var args: []const u8 = "";
        if (tc_ctx.include_cmds) {
            if (cmd.sub_cmds) |sub_cmds| {
                for (sub_cmds) |sub_cmd| args = args ++ sub_cmd.name ++ " ";
            }
            if (tc_ctx.include_usage_help) args = args ++ "help usage ";
        }
        if (tc_ctx.include_opts) {
            if (cmd.opts) |opts| {
                for (opts) |opt| {
                    if (opt.long_name) |long_name| args = args ++ long_pf ++ long_name ++ " ";
                }
            }
            if (tc_ctx.include_usage_help) args = args ++ long_pf ++ "help " ++ long_pf ++ "usage";
        }
        break :genArgList args;
    };
    if (args_list.len == 0) return;

    // Tab Completion Script Snippet Write
    try tc_writer.print(
        \\_{s}_completions() {{
        \\    local cur prev
        \\    COMPREPLY=()
        \\    cur="${{COMP_WORDS[COMP_CWORD]}}"
        \\    prev="${{COMP_WORDS[COMP_CWORD - 1]}}"
        \\
        \\    case "${{prev}}" in
        \\
    , .{
        if (tc_ctx.idx == 1) tc_ctx.name else tc_ctx.parent_name ++ "_" ++ tc_ctx.name,
    });
    var args_iter = mem.splitScalar(u8, args_list, ' ');
    while (args_iter.next()) |arg| {
        if (utils.indexOfEql([]const u8, &.{ "usage", "help" }, arg) != null or
            mem.eql(u8, if (arg.len < long_pf.len) continue else arg[0..long_pf.len], long_pf)) continue;
        try tc_writer.print(
            \\        "{s}")
            \\            _{s}_{s}_completions
            \\            ;;
            \\
        , .{
            arg,
            tc_ctx.parent_name ++ tc_ctx.name,
            arg,
        });
    }
    try tc_writer.print(
        \\        "{s}")
        \\            COMPREPLY=($(compgen -W "{s}" -- ${{cur}}))
        \\            ;;
        \\        *)
        \\            COMPREPLY=($(compgen -f -- ${{cur}}))
        \\    esac
        \\}}
        \\
        \\
    , .{
        tc_ctx.name,
        args_list,
    });

    // Iterate through sub-Commands
    if (cmd.sub_cmds) |sub_cmds| {
        comptime var next_ctx = tc_ctx;
        next_ctx.parent_name = (if (tc_ctx.parent_name.len == 0) "" else tc_ctx.parent_name ++ "_") ++ tc_ctx.name;
        next_ctx.idx += 1;
        inline for (sub_cmds) |sub_cmd| {
            next_ctx.name = sub_cmd.name;
            try cmdTabCompletionBash(CommandT, sub_cmd, tc_writer, next_ctx);
        }
    }

    if (tc_ctx.idx == 1) {
        try tc_writer.print("\ncomplete -F _{s}_completions {s}", .{
            tc_ctx.name,
            tc_ctx.name,
        });
    }
}

/// Writes a Zsh Tab Completion script snippet for the provided CommandT (`cmd`) to the given Writer (`tc_writer`).
/// This function passes the provided TabCompletionContext (`tc_ctx`) to track info through recursive calls.
fn cmdTabCompletionZsh(
    comptime CommandT: type,
    comptime cmd: CommandT,
    tc_writer: anytype,
    comptime tc_ctx: TabCompletionContext,
) !void {
    // Get Sub Commands and Options
    const long_pf = CommandT.OptionT.long_prefix orelse "";
    const args_list: []const u8 = comptime genArgList: {
        var args: []const u8 = "";
        if (tc_ctx.include_cmds) {
            if (cmd.sub_cmds) |sub_cmds| {
                for (sub_cmds) |sub_cmd| args = args ++ sub_cmd.name ++ " ";
            }
            if (tc_ctx.include_usage_help) args = args ++ "help usage ";
        }
        if (tc_ctx.include_opts) {
            if (cmd.opts) |opts| {
                for (opts) |opt| {
                    if (opt.long_name) |long_name| args = args ++ long_pf ++ long_name ++ " ";
                }
            }
            if (tc_ctx.include_usage_help) args = args ++ long_pf ++ "help " ++ long_pf ++ "usage";
        }
        break :genArgList args;
    };
    if (args_list.len == 0) return;

    // Set up Arguments Array
    if (tc_ctx.idx == 1) try tc_writer.print(
        \\# Associative array to hold Commands, Options, and their descriptions with arbitrary depth
        \\typeset -A cmd_args
        \\cmd_args=(
        \\
    , .{});

    try tc_writer.print("    \"{s}\" \"{s}\"\n", .{
        if (tc_ctx.idx == 1) cmd.name else tc_ctx.parent_name ++ "_" ++ cmd.name,
        args_list,
    });

    // Iterate through sub-Commands
    if (tc_ctx.include_cmds) addSubCmds: {
        const sub_cmds = cmd.sub_cmds orelse break :addSubCmds;
        comptime var next_ctx = tc_ctx;
        next_ctx.parent_name = (if (tc_ctx.parent_name.len == 0) "" else tc_ctx.parent_name ++ "_") ++ tc_ctx.name;
        next_ctx.idx += 1;
        inline for (sub_cmds) |sub_cmd| {
            next_ctx.name = sub_cmd.name;
            try cmdTabCompletionZsh(CommandT, sub_cmd, tc_writer, next_ctx);
        }
    }

    // Add Recursive Completion Function
    if (tc_ctx.idx == 1) {
        try tc_writer.print(
            \\)
            \\# Generic function for command completions
            \\_{s}_completions() {{
            \\    local -a completions
            \\    # Determine the current command context
            \\    local context="{s}"
            \\    for word in "${{words[@]:1:$CURRENT-1}}"; do
            \\        if [[ -n $cmd_args[${{context}}_${{word}}] ]]; then
            \\            context="${{context}}_${{word}}"
            \\        fi
            \\    done
            \\    # Generate completions for the current context
            \\    completions=(${{(s: :)cmd_args[$context]}})
            \\    if [[ -n $completions ]]; then
            \\        _describe -t commands "{s}" completions && return 0
            \\    fi
            \\}}
            \\_{s}_completions "$@"
        , .{tc_ctx.name} ** 4);
    }
}

/// Writes a PowerShell Tab Completion script snippet for the provided CommandT (`cmd`) to the given Writer (`tc_writer`).
/// This function passes the provided TabCompletionContext (`tc_ctx`) to track info through recursive calls.
fn cmdTabCompletionPowerShell(comptime CommandT: type, comptime cmd: CommandT, tc_writer: anytype, comptime tc_ctx: TabCompletionContext) !void {
    // Get Sub Commands and Options
    const long_pf = CommandT.OptionT.long_prefix orelse "";
    const suggestions: []const u8 = comptime genSuggestions: {
        var args: []const u8 = "@(\n";
        if (tc_ctx.include_cmds) {
            if (cmd.sub_cmds) |sub_cmds| {
                for (sub_cmds) |sub_cmd| args = args ++ "\t\t'" ++ sub_cmd.name ++ "',\n";
            }
            if (tc_ctx.include_usage_help) args = args ++ "\t\t'help',\n\t\t'usage',\n";
        }
        if (tc_ctx.include_opts) {
            if (cmd.opts) |opts| {
                for (opts) |opt| {
                    if (opt.long_name) |long_name| args = args ++ "\t\t'" ++ long_pf ++ long_name ++ "',\n";
                }
            }
            if (tc_ctx.include_usage_help) args = args ++ "\t\t'" ++ long_pf ++ "help',\n\t\t'" ++ long_pf ++ "usage',\n";
        }
        if (args[args.len - 2] == ',') args = args[0 .. args.len - 2] ++ "\n";
        args = args ++ "\t)";
        break :genSuggestions args;
    };
    if (suggestions.len == 0) return;

    // Tab Completion Script Snippet Write
    // TODO Handle Commands with no Arguments
    try tc_writer.print(
        \\function _{s} {{
        \\    param($wordToComplete, $commandAst)
        \\    $suggestions = {s}
        \\    return $suggestions | Where-Object {{ $_ -like "$wordToComplete*" }}
        \\}}
        \\
        \\
    , .{
        if (tc_ctx.idx == 1) tc_ctx.name else tc_ctx.parent_name ++ "-" ++ tc_ctx.name,
        suggestions,
    });

    // Iterate through sub-Commands
    if (cmd.sub_cmds) |sub_cmds| {
        comptime var next_ctx = tc_ctx;
        next_ctx.parent_name = (if (tc_ctx.parent_name.len == 0) "" else tc_ctx.parent_name ++ "-") ++ tc_ctx.name;
        next_ctx.idx += 1;
        inline for (sub_cmds) |sub_cmd| {
            next_ctx.name = sub_cmd.name;
            try cmdTabCompletionPowerShell(CommandT, sub_cmd, tc_writer, next_ctx);
        }
    }

    if (tc_ctx.idx == 1) {
        try tc_writer.print(
            \\Register-ArgumentCompleter -CommandName '{s}' -ScriptBlock {{
            \\    param($wordToComplete, $commandAst, $cursorPos)
            \\
            \\    $functionName = "_" + $($commandAst.Extent.Text.replace(' ', '-').replace(".exe", ""))
            \\    if ($wordToComplete) {{
            \\        $functionName = $functionName.replace("-$wordToComplete", "")
            \\    }}
            \\
            \\    # Check if the function exists and invoke it
            \\    if (Get-Command -Name $functionName -ErrorAction SilentlyContinue) {{
            \\        & $functionName $wordToComplete $commandAst
            \\    }} else {{
            \\        # Fallback logic to show files in the current directory
            \\        Get-ChildItem -Path '.' -File | Where-Object Name -like "*$wordToComplete*" | ForEach-Object {{
            \\            [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name)
            \\        }}
            \\    }}
            \\}}
            // TODO Make this dependent on the name given by the build
        , .{tc_ctx.name ++ ".exe"});
    }
}
